// ========== SOLTHRON EXTENSION - MAGIC PILL INTEGRATED ==========

// Global variables
let shadowRoot;
let button;
let outputText;
let selectedMode;
let solthronContainer;
let currentCategory = null;
let isButtonVisible = false;
let activePromptId = null;
let isPromptStarActive = false;
let activeChatId = null;
let isChatStarActive = false;
// Workflow state tracking
let activeWorkflow = null;
let activeWorkflowName = null;
// Right-click feature state tracking
let rightClickFeaturesEnabled = false;
let lastSelectedRightClickMode = null;
let pageCredits = null;

// ========== MAGIC PILL VARIABLES ==========
let autoModeEnabled = true; // âœ… FIX: Always enabled by default
let magicPillIcon = null;
let currentInputField = null;
let lastMagicPillClick = 0;
const MAGIC_PILL_COOLDOWN = 2000; // 2 seconds cooldown
let magicPillOriginalIcon = null;

// ========== GMAIL MAGIC PILL VARIABLES ==========
let gmailMagicPillEnabled = true;
let isGmailPage = false;
let gmailComposeField = null;
const GMAIL_CHECK_INTERVAL = 2000;

// ========== GMAIL TONE SELECTION VARIABLES ==========
let selectedEmailMode = 'balanced'; // Default mode
let toneDropdown = null;
let customPromptBar = null;
let currentCustomPrompt = '';
let customPromptBarObserver = null;
let customPromptBarUpdatePosition = null;
const emailModes = [
    { id: 'polish', label: 'âœ¨ Polish', description: 'Minimal edits - Fix grammar only' },
    { id: 'balanced', label: 'âš–ï¸ Balanced', description: 'Moderate enhancement' },
    { id: 'reframe', label: 'ðŸ”„ Reframe', description: 'Complete rewrite' },
    { id: 'prompt', label: 'ðŸŽ¯ Prompt', description: 'Custom instructions' }
];

// Load saved email mode preference
const savedEmailMode = localStorage.getItem('solthron-email-mode');
if (savedEmailMode && emailModes.some(m => m.id === savedEmailMode)) {
    selectedEmailMode = savedEmailMode;
}

// ========== @MENTIONS AUTOCOMPLETE VARIABLES ==========
let autocompleteDropdown = null;
let autocompleteMatches = [];
let selectedAutocompleteIndex = 0;
let lastAtPosition = -1;

// ========== MAGIC PILL AI PLATFORM MODE VARIABLES ==========
let selectedAIPlatformMode = 'auto'; // Default mode
let aiPlatformModeDropdown = null;
let aiPlatformCustomPromptBar = null;
let currentAIPlatformCustomPrompt = '';
let currentAIPlatformSelectedText = ''; // Store selected text
let aiPlatformCustomPromptBarObserver = null;
let aiPlatformCustomPromptBarUpdatePosition = null;
const aiPlatformModes = [
    { id: 'auto', label: 'âš¡ Auto Mode', description: 'Smart enhancement' },
    { id: 'convert_balanced', label: 'ðŸ“ Convert to Balanced Prompt', description: 'Convert to structured prompt' },
    { id: 'customize', label: 'ðŸŽ¯ Customize', description: 'Custom conversion instructions' }
];

// âœ¨ Double-click animation function
function triggerDoubleClickAnimation() {
    const solthronButton = shadowRoot.querySelector('.solthron-button');
    
    if (!solthronButton) return;
    
    solthronButton.classList.remove('double-click-activated');
    solthronButton.offsetHeight; // Force reflow
    solthronButton.classList.add('double-click-activated');
    
    setTimeout(() => {
        solthronButton.classList.remove('double-click-activated');
    }, 600);
}

// Loading Bar Helper Functions
function showShimmerLoading(message) {
    outputText.classList.remove('placeholder', 'error');
    outputText.classList.add('shimmer-loading');
    outputText.textContent = message;
}

function hideShimmerLoading() {
    outputText.classList.remove('shimmer-loading');
}

// Feature-to-credit mapping function
function getFeatureCredits(mode) {
    const explainModes = ['explain_meaning', 'explain_story', 'explain_eli5'];
    const aiAssistantModes = ['smart_followups']
    const imageModes = ['image_prompt']; // Removed image_caption
    const freeModes = ['save_note', 'save_prompt', 'save_persona'];
    const magicPillModes = ['magic_pill_enhance'];

    
    if (explainModes.includes(mode)) return 5;
    if (aiAssistantModes.includes(mode)) return 15;
    if (imageModes.includes(mode)) return 12;
    if (freeModes.includes(mode)) return 0;
    if (magicPillModes.includes(mode)) return 10;
    
    return 6;
}

// ========== PLATFORM DETECTION ==========
function detectAIPlatform() {
    const hostname = window.location.hostname;
    const pathname = window.location.pathname;
    
    // Check for Gmail first
    if (hostname.includes('mail.google.com')) {
        isGmailPage = true;
        return 'gmail';
    }
    
    if (hostname.includes('chatgpt.com') || hostname.includes('chat.openai.com')) {
        return 'chatgpt';
    } else if (hostname.includes('claude.ai')) {
        return 'claude';
    } else if (hostname.includes('gemini.google.com') || hostname.includes('bard.google.com')) {
        return 'gemini';
    } else if (hostname.includes('chat.deepseek.com')) {
        return 'deepseek';
    } else if (hostname.includes('grok.x.com') || (hostname.includes('x.com') && pathname.includes('grok'))) {
        return 'grok';
    } else if (hostname.includes('perplexity.ai')) {
        return 'perplexity';
    }
    return 'unknown';
}

// ========== EXTRACT LAST Q&A EXCHANGE ==========
function extractLastExchange(platform) {
    try {
        switch(platform) {
            case 'chatgpt':
                return extractChatGPTLastExchange();
            case 'claude':
                return extractClaudeLastExchange();
            case 'gemini':
                return extractGeminiLastExchange();
            case 'deepseek':
                return extractDeepSeekLastExchange();
            case 'grok':
                return extractGrokLastExchange();
            case 'perplexity':
                return extractPerplexityLastExchange();
            default:
                return null;
        }
    } catch (error) {
        console.error('Error extracting last exchange:', error);
        return null;
    }
}

function extractChatGPTLastExchange() {
    const messages = document.querySelectorAll('[data-message-author-role]');
    
    if (messages.length < 2) return null;
    
    // Get last two messages (user question + AI answer)
    const userMessage = messages[messages.length - 2];
    const aiMessage = messages[messages.length - 1];
    
    // Verify roles
    const userRole = userMessage.getAttribute('data-message-author-role');
    const aiRole = aiMessage.getAttribute('data-message-author-role');
    
    if (userRole !== 'user' || aiRole !== 'assistant') {
        return null;
    }
    
    return {
        question: userMessage.textContent.trim(),
        answer: aiMessage.textContent.trim()
    };
}

function extractClaudeLastExchange() {
    // Get all message containers
    const allMessages = document.querySelectorAll('.font-user-message, .font-claude-message');
    
    if (allMessages.length < 2) return null;
    
    // Get last two
    const userMessage = allMessages[allMessages.length - 2];
    const aiMessage = allMessages[allMessages.length - 1];
    
    // Verify they're the right type
    if (!userMessage.classList.contains('font-user-message') || 
        !aiMessage.classList.contains('font-claude-message')) {
        return null;
    }
    
    return {
        question: userMessage.textContent.trim(),
        answer: aiMessage.textContent.trim()
    };
}

function extractGeminiLastExchange() {
    // Try multiple selectors for Gemini
    const userMessages = document.querySelectorAll('[class*="user-message"], [data-message-author="user"]');
    const aiMessages = document.querySelectorAll('[class*="model-message"], [class*="response-container"]');
    
    if (userMessages.length === 0 || aiMessages.length === 0) return null;
    
    const lastUserMsg = userMessages[userMessages.length - 1];
    const lastAiMsg = aiMessages[aiMessages.length - 1];
    
    return {
        question: lastUserMsg?.textContent.trim() || '',
        answer: lastAiMsg?.textContent.trim() || ''
    };
}

function extractDeepSeekLastExchange() {
    const messages = document.querySelectorAll('.message-container, [class*="message"]');
    
    if (messages.length < 2) return null;
    
    const userMessage = messages[messages.length - 2];
    const aiMessage = messages[messages.length - 1];
    
    return {
        question: userMessage?.textContent.trim() || '',
        answer: aiMessage?.textContent.trim() || ''
    };
}

function extractGrokLastExchange() {
    // Similar to ChatGPT structure
    const messages = document.querySelectorAll('[data-testid*="message"], .message');
    
    if (messages.length < 2) return null;
    
    return {
        question: messages[messages.length - 2]?.textContent.trim() || '',
        answer: messages[messages.length - 1]?.textContent.trim() || ''
    };
}

function extractPerplexityLastExchange() {
    const userMessages = document.querySelectorAll('[class*="user"]');
    const aiMessages = document.querySelectorAll('[class*="assistant"], [class*="answer"]');
    
    if (userMessages.length === 0 || aiMessages.length === 0) return null;
    
    return {
        question: userMessages[userMessages.length - 1]?.textContent.trim() || '',
        answer: aiMessages[aiMessages.length - 1]?.textContent.trim() || ''
    };
}

// ========== GMAIL CONTEXT EXTRACTION ==========
function extractGmailContext() {
    const context = {
        isReply: false,
        recipients: [],
        subject: '',
        previousEmails: [],
        isCompose: true
    };
    
    try {
        // Check if it's a reply
        const replyIndicators = document.querySelectorAll('.gmail_quote, .gmail_attr, blockquote');
        context.isReply = replyIndicators.length > 0;
        
        // Get recipients (TO field)
        const toFields = document.querySelectorAll('input[name="to"], span[email], .vR span[email]');
        toFields.forEach(field => {
            const email = field.getAttribute('email') || field.value;
            if (email && !context.recipients.includes(email)) {
                context.recipients.push(email);
            }
        });
        
        // Get subject line
        const subjectField = document.querySelector('input[name="subjectbox"], input[name="subject"]');
        if (subjectField) {
            context.subject = subjectField.value;
        }
        
        // Detect if formal (based on domain)
        context.isFormal = context.recipients.some(email => {
            return email.includes('.gov') || 
                   email.includes('.edu') || 
                   email.includes('ceo') || 
                   email.includes('director') ||
                   email.includes('manager');
        });
        
        // Get thread context if reply
        if (context.isReply) {
            const quotedText = document.querySelector('.gmail_quote, .ii.gt');
            if (quotedText) {
                context.previousEmails = quotedText.innerText.substring(0, 500); // First 500 chars for context
            }
        }
        
    } catch (error) {

    }
    
    return context;
}

// ========== CURSOR POSITION UTILITIES ==========
function getCursorPosition(element) {
    try {
        if (element.tagName === 'TEXTAREA') {
            return getCursorPositionTextarea(element);
        } else {
            return getCursorPositionContentEditable(element);
        }
    } catch (error) {
        console.warn('Error getting cursor position:', error);
        return null;
    }
}

function getCursorPositionContentEditable(element) {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) return null;

    try {
        const range = selection.getRangeAt(0);

        // âœ… FIX: Check if range is actually within our target element
        if (!element.contains(range.commonAncestorContainer)) {
            console.warn('âš ï¸ Selection is not within target element');
            return null;
        }

        const rect = range.getBoundingClientRect();

        // âœ… FIX: Better validation of rect
        if (rect.left === 0 && rect.top === 0 && rect.width === 0 && rect.height === 0) {
            // Completely empty rect, likely invalid selection
            return null;
        }

        // If range has no width/height, it's probably collapsed at cursor
        if (rect.width === 0 && rect.height === 0) {
            return {
                x: rect.left,
                y: rect.top,
                height: 20 // fallback height
            };
        }

        // For text selection, use the end of the range
        const endRange = range.cloneRange();
        endRange.collapse(false);
        const endRect = endRange.getBoundingClientRect();

        return {
            x: endRect.left || rect.left,
            y: endRect.top || rect.top,
            height: endRect.height || rect.height || 20
        };
    } catch (error) {
        console.warn('âš ï¸ Error getting cursor position:', error);
        return null;
    }
}

function getCursorPositionTextarea(element) {
    const selectionStart = element.selectionStart;
    const text = element.value.substring(0, selectionStart);
    
    // Create a temporary element to measure text
    const measurer = createTextMeasurer(element);
    const position = measureTextPosition(measurer, text, element);
    
    // Clean up
    document.body.removeChild(measurer);
    
    return position;
}

function createTextMeasurer(textarea) {
    const measurer = document.createElement('div');
    const style = window.getComputedStyle(textarea);
    const platform = detectAIPlatform();
    
    // Base styling that works for all platforms
    let measurerCSS = `
        position: absolute;
        visibility: hidden;
        height: auto;
        width: ${textarea.offsetWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight)}px;
        font: ${style.font};
        font-family: ${style.fontFamily};
        font-size: ${style.fontSize};
        font-weight: ${style.fontWeight};
        line-height: ${style.lineHeight};
        letter-spacing: ${style.letterSpacing};
        white-space: pre-wrap;
        word-wrap: break-word;
        padding: ${style.paddingTop} ${style.paddingRight} ${style.paddingBottom} ${style.paddingLeft};
        border: ${style.border};
        box-sizing: ${style.boxSizing};
        z-index: -1;
    `;
    
    // Platform-specific positioning
    if (platform === 'deepseek' || platform === 'grok') {
        // For DeepSeek and Grok, position the measurer element exactly over the textarea
        const rect = textarea.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
        
        measurerCSS += `
            top: ${rect.top + scrollTop}px;
            left: ${rect.left + scrollLeft}px;
        `;
    } else {
        // For other platforms, use the original positioning (off-screen)
        measurerCSS += `
            top: -9999px;
            left: -9999px;
        `;
    }
    
    measurer.style.cssText = measurerCSS;
    document.body.appendChild(measurer);
    return measurer;
}

function measureTextPosition(measurer, text, textarea) {
    // Add text up to cursor position
    measurer.textContent = text;
    
    // Add a marker span at the end to get cursor position
    const marker = document.createElement('span');
    marker.textContent = '|';
    measurer.appendChild(marker);
    
    const textareaRect = textarea.getBoundingClientRect();
    const markerRect = marker.getBoundingClientRect();
    const measurerRect = measurer.getBoundingClientRect();
    
    // Platform-specific coordinate calculation
    const platform = detectAIPlatform();
    
    if (platform === 'deepseek' || platform === 'grok') {
        // DeepSeek and Grok need special coordinate handling
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
        
        // Calculate relative position within measurer, then translate to textarea coordinates
        const relativeX = markerRect.left - measurerRect.left;
        const relativeY = markerRect.top - measurerRect.top;
        
        return {
            x: textareaRect.left + relativeX,
            y: textareaRect.top + relativeY,
            height: markerRect.height || 20
        };
    } else {
        // Original logic for other platforms (ChatGPT, Claude, Gemini)
        return {
            x: markerRect.left,
            y: markerRect.top,
            height: markerRect.height || 20
        };
    }
}

// ========== MAGIC PILL FUNCTIONS ==========
function initializeMagicPill() {
    const platform = detectAIPlatform();

    
    if (platform === 'unknown') {

        return;
    }
    
    if (!autoModeEnabled) {

        removeMagicPill();
        return;
    }
    

    monitorInputField(platform);
}

function monitorInputField(platform) {
    const findAndMonitorInput = () => {
        let inputField = null;
        
        // Platform-specific selectors
        const selectors = {
            chatgpt: [
                '#prompt-textarea',
                'textarea[data-id="root"]',
                'textarea[id*="prompt"]',
                'textarea[placeholder*="Send"]',
                'textarea[placeholder*="Message"]',
                'div[contenteditable="true"][data-id]',
                'div[contenteditable="true"]',
                'textarea'
            ],
            claude: [
                'div.ProseMirror[contenteditable="true"]',
                'div[contenteditable="true"][data-placeholder]',
                'div[contenteditable="true"]'
            ],
            gemini: [
                '.ql-editor[contenteditable="true"]',
                'div[contenteditable="true"][aria-label*="message"]',
                'div[contenteditable="true"]',
                'rich-textarea .ql-editor'
            ],
            deepseek: [
                'textarea[placeholder*="Message"]',
                'textarea.chat-input',
                'div[contenteditable="true"]',
                'textarea'
            ],
            grok: [
                'textarea[placeholder*="Enter"]',
                'textarea[placeholder*="Message"]',
                'textarea[placeholder*="Type"]',
                'div[contenteditable="true"]',
                'textarea.input',
                'textarea',
                '#chat-input',
                '.chat-input'
            ],
            gmail: [  // âœ… ADD GMAIL DIRECTLY HERE
                'div[role="textbox"][aria-label*="Message Body"]',
                'div[contenteditable="true"][aria-label*="compose"]',
                'div.editable[contenteditable="true"]',
                'div.Am.Al.editable',
                'div[g_editable="true"]'
            ]
        };
        
        const platformSelectors = selectors[platform] || [];
        
        for (const selector of platformSelectors) {
            const elements = document.querySelectorAll(selector);
            for (const el of elements) {
                // Check if this is likely the main input field
                const rect = el.getBoundingClientRect();
                const style = window.getComputedStyle(el);
                
                // Enhanced checks for visibility and usability
                if (rect.width > 200 && 
                    rect.height > 20 && 
                    style.display !== 'none' && 
                    style.visibility !== 'hidden' &&
                    !el.disabled &&
                    !el.readOnly) {
                    
                    inputField = el;

                    break;
                }
            }
            if (inputField) break;
        }
        
        // âœ… FIX: Always check if we need to attach to a new field
        if (inputField && inputField !== currentInputField) {

            currentInputField = inputField;
            attachMagicPillToInput(inputField);
        } else if (!inputField && currentInputField) {

            currentInputField = null;
            hideMagicPill();
        }
    };
    
    // Initial check
    findAndMonitorInput();
    
    // âœ… FIX: Less aggressive monitoring for ChatGPT to avoid icon conflicts
    const platformMonitoringIntervals = {
        claude: 1500,     // Claude recreates input after responses
        gemini: 1500,     // Gemini also recreates input
        deepseek: 1500,   // DeepSeek recreates input
        chatgpt: 4000,    // âœ… FIX: Slower for ChatGPT to avoid icon conflicts
        grok: 2000,       // Grok moderate recreation
        gmail: 2000       // âœ… ADD GMAIL MONITORING INTERVAL
    };
    
    const monitorInterval = platformMonitoringIntervals[platform] || 2000;
    
    // âœ… FIX: Monitoring for all platforms including ChatGPT
    const platformMonitor = setInterval(() => {
        if (autoModeEnabled) {
            findAndMonitorInput();
        }
    }, monitorInterval);

    // Store interval for cleanup if needed
    window[`solthron${platform}Monitor`] = platformMonitor;
    
    // âœ… FIX: Enhanced mutation observer that catches input field changes
    const inputObserver = new MutationObserver((mutations) => {
        if (!autoModeEnabled) return;
        
        let shouldCheck = false;
        mutations.forEach(mutation => {
            // Check for new input-related elements
            if (mutation.type === 'childList') {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === 1) { // Element node
                        // Check if the added node contains input fields
                        if (node.querySelector && (
                            node.querySelector('textarea') ||
                            node.querySelector('[contenteditable="true"]') ||
                            node.matches && (
                                node.matches('textarea') ||
                                node.matches('[contenteditable="true"]')
                            )
                        )) {
                            shouldCheck = true;
                        }
                    }
                });
            }
        });
        
        if (shouldCheck) {

            setTimeout(findAndMonitorInput, 300);
        }
    });
    
    inputObserver.observe(document.body, {
        childList: true,
        subtree: true
    });
}

// âœ… FIX: Enhanced attachment that handles field replacement
// âœ… FIX: Enhanced attachment that handles field replacement AND autocomplete
function attachMagicPillToInput(inputField) {
    console.log('ðŸ”— Attaching Magic Pill + Autocomplete to input field');

    // âœ… FIX: Always remove existing listeners first (even if field is different)
    if (currentInputField && currentInputField !== inputField) {
        try {
            currentInputField.removeEventListener('input', handleInputChange);
            currentInputField.removeEventListener('focus', handleInputFocus);
            currentInputField.removeEventListener('blur', handleInputBlur);
            currentInputField.removeEventListener('keyup', handleCursorMove);
            currentInputField.removeEventListener('click', handleCursorMove);
            currentInputField.removeEventListener('keydown', handleKeyboardShortcut);
            currentInputField.removeEventListener('keydown', handleAutocompleteKeydown);
            currentInputField.removeEventListener('input', handleAutocompleteInput);
            console.log('ðŸ§¹ Removed old listeners from previous field');
        } catch (error) {
            console.warn('âš ï¸ Error removing old listeners:', error);
        }
    }

    // âœ… FIX: Remove global scroll listener if it exists
    if (window.solthronScrollHandler) {
        window.removeEventListener('scroll', window.solthronScrollHandler, true);
        document.removeEventListener('scroll', window.solthronScrollHandler, true);
    }

    // Add listeners to new field
    try {
        inputField.addEventListener('input', handleInputChange);
        inputField.addEventListener('focus', handleInputFocus);
        inputField.addEventListener('blur', handleInputBlur);
        inputField.addEventListener('keyup', handleCursorMove);
        inputField.addEventListener('click', handleCursorMove);
        inputField.addEventListener('keydown', handleKeyboardShortcut);

        // âœ… NEW: Add autocomplete listeners
        inputField.addEventListener('keydown', handleAutocompleteKeydown, true); // Use capture phase
        inputField.addEventListener('input', handleAutocompleteInput);
        inputField.addEventListener('keydown', handleQuickSave, true); // Quick save listener

        // âœ… FIX: Add scroll listener to reposition magic pill
        window.solthronScrollHandler = () => {
            if (magicPillIcon && magicPillIcon.style.display !== 'none' && currentInputField) {
                positionMagicPillAtCursor(currentInputField);
            }
        };
        window.addEventListener('scroll', window.solthronScrollHandler, true);
        document.addEventListener('scroll', window.solthronScrollHandler, true);

        console.log('âœ… Attached all listeners (Magic Pill + Autocomplete + Scroll) to new field');
    } catch (error) {
        console.error('âŒ Failed to attach listeners:', error);
    }
}

let inputDebounceTimer = null;
let cursorMoveTimer = null;

function handleInputChange(e) {
    if (!autoModeEnabled) return;

    // âœ… FIX: Validate the field is still valid
    if (!e.target || !document.body.contains(e.target)) {
        return;
    }

    // Clear previous timer
    if (inputDebounceTimer) {
        clearTimeout(inputDebounceTimer);
    }

    // Debounce input changes
    inputDebounceTimer = setTimeout(() => {
        // âœ… FIX: Double-check field is still valid after timeout
        if (!e.target || !document.body.contains(e.target)) {
            return;
        }

        const text = getInputText(e.target);

        if (text.trim().length > 0) {
            showMagicPill(e.target);
        } else {
            hideMagicPill();
        }
    }, 300);
}

function handleKeyboardShortcut(e) {
    if (!autoModeEnabled) return;
    
    // Check for Ctrl+Shift+Enter
    if (e.ctrlKey && e.shiftKey && e.key === 'Enter') {
        e.preventDefault();
        e.stopPropagation();
        
        // Only trigger if magic pill is visible and there's text
        const text = getInputText(e.target);
        if (text.trim().length > 0 && magicPillIcon && magicPillIcon.style.display !== 'none') {
            
            
            // Create a synthetic event object for handleMagicPillClick
            const syntheticEvent = {
                preventDefault: () => {},
                stopPropagation: () => {}
            };
            
            // Trigger the same logic as clicking the magic pill
            handleMagicPillClick(syntheticEvent);
        }
    }
}

function handleCursorMove(e) {
    if (!autoModeEnabled) return;

    // âœ… FIX: Validate the field is still valid
    if (!e.target || !document.body.contains(e.target)) {
        return;
    }

    // Clear previous timer
    if (cursorMoveTimer) {
        clearTimeout(cursorMoveTimer);
    }

    // Debounce cursor movements
    cursorMoveTimer = setTimeout(() => {
        // âœ… FIX: Double-check field is still valid after timeout
        if (!e.target || !document.body.contains(e.target)) {
            return;
        }

        const text = getInputText(e.target);
        if (text.trim().length > 0 && magicPillIcon && magicPillIcon.style.display !== 'none') {
            positionMagicPillAtCursor(e.target);
        }
    }, 100);
}

function handleInputFocus(e) {
    if (!autoModeEnabled) return;
    
    const text = getInputText(e.target);
    if (text.trim().length > 0) {
        showMagicPill(e.target);
    }
}

function handleInputBlur(e) {
    setTimeout(() => {
        if (!magicPillIcon?.matches(':hover')) {
            hideMagicPill();
        }
    }, 200);
}

function getInputText(element) {
    // Handle both textarea and contenteditable
    if (element.tagName === 'TEXTAREA') {
        return element.value || '';
    } else {
        // For contenteditable (especially React apps like ChatGPT)
        // Try multiple methods to get the most accurate text
        let text = '';

        // Method 1: Try innerText (preserves line breaks, excludes hidden elements)
        if (element.innerText !== undefined) {
            text = element.innerText;
        }

        // Method 2: Fallback to textContent if innerText is empty
        if (!text && element.textContent !== undefined) {
            text = element.textContent;
        }

        // Method 3: For React apps, try to get value from data attributes
        if (!text && element.getAttribute('data-value')) {
            text = element.getAttribute('data-value');
        }

        return text || '';
    }
}

function setInputText(element, text) {
    const platform = detectAIPlatform();

    if (element.tagName === 'TEXTAREA') {
        // For textarea elements (including ChatGPT when using textarea)
        const nativeTextareaSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value').set;
        nativeTextareaSetter.call(element, text);

        // Trigger React's onChange by dispatching input event
        const inputEvent = new Event('input', { bubbles: true });
        element.dispatchEvent(inputEvent);
        element.dispatchEvent(new Event('change', { bubbles: true }));
    } else {
        // For contenteditable elements

        // Helper function to convert line breaks to <br> tags safely
        const textToHTML = (str) => {
            // Escape HTML special characters to prevent XSS
            const escaped = str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
            // Convert newlines to <br> tags
            return escaped.replace(/\n/g, '<br>');
        };

        // Platform-specific handling
        if (platform === 'chatgpt') {
            // âœ… ChatGPT uses React with contentEditable
            // We need to update the DOM and trigger React's synthetic events

            // Method 1: Try using the native input value setter if available
            const nativeInputSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value');
            if (nativeInputSetter && nativeInputSetter.set) {
                try {
                    nativeInputSetter.set.call(element, text);
                } catch (e) {
                    // Fallback if setter doesn't work
                    console.log('Native setter failed, using direct DOM manipulation');
                }
            }

            // Update the DOM content with proper line break formatting
            element.innerHTML = textToHTML(text);

            // Trigger React's synthetic event system
            // This is crucial for React to detect the change
            const inputEvent = new Event('input', { bubbles: true, cancelable: true });
            const changeEvent = new Event('change', { bubbles: true, cancelable: true });

            // Dispatch events in the order React expects
            element.dispatchEvent(new InputEvent('beforeinput', {
                bubbles: true,
                cancelable: true,
                data: text,
                inputType: 'insertText'
            }));
            element.dispatchEvent(inputEvent);
            element.dispatchEvent(changeEvent);

            // Additional events that might help React detect the change
            element.dispatchEvent(new Event('keyup', { bubbles: true }));
            element.dispatchEvent(new Event('keydown', { bubbles: true }));

        } else if (platform === 'claude') {
            // Claude uses ProseMirror - use innerHTML with line break conversion
            element.innerHTML = textToHTML(text);
            element.dispatchEvent(new InputEvent('beforeinput', { bubbles: true }));
            element.dispatchEvent(new InputEvent('input', { bubbles: true }));
        } else if (platform === 'gemini') {
            // Gemini might use Quill editor - use innerHTML with line break conversion
            element.innerHTML = textToHTML(text);
            element.dispatchEvent(new Event('textInput', { bubbles: true }));
            element.dispatchEvent(new Event('input', { bubbles: true }));
        } else {
            // Default for other platforms - use innerHTML with line break conversion
            element.innerHTML = textToHTML(text);
            element.dispatchEvent(new Event('input', { bubbles: true }));
        }
    }

    // Set focus and move cursor to end
    element.focus();

    if (element.tagName !== 'TEXTAREA') {
        try {
            const range = document.createRange();
            const selection = window.getSelection();
            range.selectNodeContents(element);
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
        } catch (e) {
            // Cursor positioning might fail in some cases, that's okay
            console.log('Cursor positioning failed:', e);
        }
    }
}

function showMagicPill(inputField) {
    if (!magicPillIcon) {
        createMagicPillIcon();
    }
    
    positionMagicPillAtCursor(inputField);
    
    magicPillIcon.style.display = 'flex';
    setTimeout(() => {
        magicPillIcon.style.opacity = '1';
        magicPillIcon.style.transform = 'scale(1)';
    }, 10);
}

function hideMagicPill() {
    if (!magicPillIcon) return;
    
    magicPillIcon.style.opacity = '0';
    magicPillIcon.style.transform = 'scale(0.8)';
    
    setTimeout(() => {
        if (magicPillIcon) {
            magicPillIcon.style.display = 'none';
        }
    }, 200);
}

function positionMagicPillAtCursor(inputField) {
    if (!magicPillIcon) return;

    // âœ… FIX: Validate input field is still in DOM
    if (!inputField || !document.body.contains(inputField)) {
        console.warn('âš ï¸ Input field is stale or removed from DOM');
        hideMagicPill();
        return;
    }

    const cursorPos = getCursorPosition(inputField);

    if (!cursorPos) {
        // Use fallback positioning
        positionMagicPillFallback(inputField);
        return;
    }
    
    const platform = detectAIPlatform();
    
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    
    // Calculate position relative to cursor
    let x = cursorPos.x + scrollLeft + 10; // 10px to the right of cursor
    let y = cursorPos.y + scrollTop - 40; // 40px above cursor
    
    // Viewport boundary checks
    const pillWidth = 32;
    const pillHeight = 32;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Adjust horizontal position if too close to right edge
    if (x + pillWidth > viewportWidth + scrollLeft - 10) {
        x = cursorPos.x + scrollLeft - pillWidth - 10; // Position to the left of cursor
    }
    
    // Adjust vertical position if too close to top edge
    if (y < scrollTop + 10) {
        y = cursorPos.y + scrollTop + (cursorPos.height || 20) + 10; // Position below cursor
    }
    
    // Apply position
    magicPillIcon.style.left = `${x}px`;
    magicPillIcon.style.top = `${y}px`;
}

function positionMagicPillFallback(inputField) {
    // Fallback to original positioning method
    const rect = inputField.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    
    // Position at the right edge, vertically centered
    magicPillIcon.style.top = `${rect.top + scrollTop + (rect.height / 2) - 16}px`;
    magicPillIcon.style.left = `${rect.right + scrollLeft - 45}px`;
}

function createMagicPillIcon() {
    removeMagicPill();

    // âœ… ADD THIS: Inject bounce animation into global document if not already present
    if (!document.querySelector('#solthron-bounce-animation')) {
        const style = document.createElement('style');
        style.id = 'solthron-bounce-animation';
        style.textContent = `
            @keyframes bounce {
                0%, 80%, 100% {
                    transform: translateY(0) scale(1);
                    opacity: 1;
                }
                40% {
                    transform: translateY(-2px) scale(1.05);
                    opacity: 0.9;
                }
            }
        `;
        document.head.appendChild(style);
    }

    
    magicPillIcon = document.createElement('div');
    magicPillIcon.id = 'solthron-magic-pill';
    magicPillIcon.style.cssText = `
        position: absolute;
        width: 32px;
        height: 32px;
        background: #ffff00;
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 999999;
        opacity: 0;
        transform: scale(0.8);
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15), 0 0 20px rgba(255, 255, 0, 0.3);
        pointer-events: auto;
    `;
    
    // Store the original icon HTML globally
    magicPillOriginalIcon = `
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#000" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 2v6m0 4v6m0 4v-2"></path>
            <path d="M2 12h6m4 0h6m4 0h-2"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    `;
    
    magicPillIcon.innerHTML = magicPillOriginalIcon;
    
    magicPillIcon.addEventListener('mouseenter', () => {
        magicPillIcon.style.transform = 'scale(1.1)';
        magicPillIcon.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2), 0 0 25px rgba(255, 255, 0, 0.4)';
    });
    
    magicPillIcon.addEventListener('mouseleave', () => {
        magicPillIcon.style.transform = 'scale(1)';
        magicPillIcon.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.15), 0 0 20px rgba(255, 255, 0, 0.3)';
    });
    
    // Left-click handler - use default tone
    magicPillIcon.addEventListener('click', handleMagicPillClick);
    
    // âœ¨ Right-click handler for mode selection
    magicPillIcon.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();

        const platform = detectAIPlatform();
        console.log('ðŸ–±ï¸ Right-click on magic pill, platform:', platform);

        // âœ… CRITICAL: Save text from input field NOW (for AI platforms, use input field text like Gmail uses compose field)
        if (platform !== 'gmail' && platform !== 'unknown') {
            console.log('ðŸ” currentInputField:', currentInputField);
            console.log('ðŸ” currentInputField exists:', !!currentInputField);

            // For AI platforms, get text from the input field (not window selection)
            if (currentInputField) {
                currentAIPlatformSelectedText = getInputText(currentInputField);
                console.log(`ðŸ’¾ Saved text from input field on right-click (${currentAIPlatformSelectedText.length} chars): "${currentAIPlatformSelectedText.substring(0, 50)}..."`);

                // Extra validation
                if (!currentAIPlatformSelectedText || currentAIPlatformSelectedText.trim().length === 0) {
                    console.warn('âš ï¸ getInputText returned empty, trying direct access');
                    // Try direct access as fallback
                    if (currentInputField.tagName === 'TEXTAREA' || currentInputField.tagName === 'INPUT') {
                        currentAIPlatformSelectedText = currentInputField.value;
                    } else if (currentInputField.isContentEditable || currentInputField.contentEditable === 'true') {
                        currentAIPlatformSelectedText = currentInputField.innerText || currentInputField.textContent || '';
                    }
                    console.log(`ðŸ”„ Direct access result: ${currentAIPlatformSelectedText.length} chars`);
                }
            } else {
                console.error('âŒ No input field found on right-click');
                currentAIPlatformSelectedText = '';
            }
        }

        if (platform === 'gmail') {
            // Gmail: Show tone dropdown
            showToneDropdown(e.pageX, e.pageY);
        } else if (platform !== 'unknown') {
            // AI platforms: Show mode dropdown
            showAIPlatformModeDropdown(e.pageX, e.pageY);
        } else {
            // Unknown platform: just trigger regular enhancement
            handleMagicPillClick(e);
        }
    });
    
    document.body.appendChild(magicPillIcon);
}

function showToneDropdown(x, y) {
    // Remove any existing dropdown
    if (toneDropdown) {
        toneDropdown.remove();
    }
    
    // Create dropdown container (temporarily invisible to measure)
    toneDropdown = document.createElement('div');
    toneDropdown.style.cssText = `
        position: absolute;
        left: 0px;
        top: 0px;
        background: #2a2a2a;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 4px;
        z-index: 1000000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        min-width: 220px;
        visibility: hidden; /* Hide initially to measure */
    `;
    
    // Add animation style if not present
    if (!document.querySelector('#tone-dropdown-animation')) {
        const style = document.createElement('style');
        style.id = 'tone-dropdown-animation';
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: scale(0.95); }
                to { opacity: 1; transform: scale(1); }
            }
        `;
        document.head.appendChild(style);
    }
    
    // Add header showing current selection
    const header = document.createElement('div');
    header.style.cssText = `
        padding: 8px 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.6);
        font-size: 11px;
        text-align: center;
    `;
    header.textContent = `Current: ${selectedEmailMode.charAt(0).toUpperCase() + selectedEmailMode.slice(1)}`;
    toneDropdown.appendChild(header);
    
    // Create mode options
    emailModes.forEach(mode => {
        const option = document.createElement('div');
        const isSelected = mode.id === selectedEmailMode;
        
        option.style.cssText = `
            padding: 8px 12px;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            ${isSelected ? 'background: rgba(255, 255, 0, 0.1);' : ''}
        `;
        
        option.innerHTML = `
            <span style="font-size: 16px;">${mode.label.split(' ')[0]}</span>
            <div style="flex: 1;">
                <div style="font-weight: 500;">${mode.label.substring(2)}</div>
                <div style="font-size: 11px; color: rgba(255,255,255,0.6);">${mode.description}</div>
            </div>
            ${isSelected ? '<span style="color: #ffff00;">âœ“</span>' : ''}
        `;
        
        option.addEventListener('mouseenter', () => {
            if (!isSelected) {
                option.style.background = 'rgba(255, 255, 255, 0.1)';
            }
        });
        
        option.addEventListener('mouseleave', () => {
            if (!isSelected) {
                option.style.background = 'transparent';
            }
        });
        
        option.addEventListener('click', (e) => {
            e.stopPropagation();
            selectedEmailMode = mode.id;
            console.log(`ðŸ“§ Gmail tone mode set to: ${mode.label}`);

            // Save preference (only if not 'prompt' mode)
            if (mode.id !== 'prompt') {
                localStorage.setItem('solthron-email-mode', mode.id);
            }

            // Show confirmation
            option.style.background = 'rgba(0, 255, 0, 0.2)';
            setTimeout(() => {
                toneDropdown.remove();
                toneDropdown = null;

                // If 'prompt' mode selected, show custom input bar
                if (mode.id === 'prompt') {
                    showCustomPromptBar();
                }
            }, 200);

            // âœ… ONLY set the mode - user must left-click Magic Pill to trigger enhancement
        });
        
        toneDropdown.appendChild(option);
    });
    
    // Add to document to measure dimensions
    document.body.appendChild(toneDropdown);
    
    // Get dropdown dimensions
    const dropdownRect = toneDropdown.getBoundingClientRect();
    const dropdownWidth = dropdownRect.width;
    const dropdownHeight = dropdownRect.height;
    
    // Get viewport dimensions
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Calculate optimal position
    let finalX = x;
    let finalY = y;
    
    // Check horizontal overflow
    if (x + dropdownWidth > viewportWidth - 10) {
        // Position to the left of cursor instead
        finalX = Math.max(10, x - dropdownWidth);
    }
    
    // Check vertical overflow
    if (y + dropdownHeight > viewportHeight - 10) {
        // Position above cursor instead
        finalY = Math.max(10, y - dropdownHeight);
    }
    
    // Apply final position and make visible
    toneDropdown.style.left = `${finalX}px`;
    toneDropdown.style.top = `${finalY}px`;
    toneDropdown.style.visibility = 'visible';
    toneDropdown.style.animation = 'fadeIn 0.2s ease';
    
    // Close dropdown when clicking elsewhere
    const closeDropdown = (e) => {
        if (toneDropdown && !toneDropdown.contains(e.target)) {
            toneDropdown.remove();
            toneDropdown = null;
            document.removeEventListener('click', closeDropdown);
        }
    };
    
    setTimeout(() => {
        document.addEventListener('click', closeDropdown);
    }, 100);
}

function showAIPlatformModeDropdown(x, y) {
    // Remove any existing dropdown
    if (aiPlatformModeDropdown) {
        aiPlatformModeDropdown.remove();
    }

    // Create dropdown container
    aiPlatformModeDropdown = document.createElement('div');
    aiPlatformModeDropdown.style.cssText = `
        position: absolute;
        left: 0px;
        top: 0px;
        background: #2a2a2a;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 4px;
        z-index: 1000000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        min-width: 240px;
        visibility: hidden;
    `;

    // Add header showing current selection
    const header = document.createElement('div');
    header.style.cssText = `
        padding: 8px 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.6);
        font-size: 11px;
        text-align: center;
    `;
    const currentMode = aiPlatformModes.find(m => m.id === selectedAIPlatformMode);
    header.textContent = `Current: ${currentMode ? currentMode.label.substring(2) : 'Auto Mode'}`;
    aiPlatformModeDropdown.appendChild(header);

    // Create mode options
    aiPlatformModes.forEach(mode => {
        const option = document.createElement('div');
        const isSelected = mode.id === selectedAIPlatformMode;

        option.style.cssText = `
            padding: 8px 12px;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            ${isSelected ? 'background: rgba(255, 255, 0, 0.1);' : ''}
        `;

        option.innerHTML = `
            <span style="font-size: 16px;">${mode.label.split(' ')[0]}</span>
            <div style="flex: 1;">
                <div style="font-weight: 500;">${mode.label.substring(2)}</div>
                <div style="font-size: 11px; color: rgba(255,255,255,0.6);">${mode.description}</div>
            </div>
            ${isSelected ? '<span style="color: #ffff00;">âœ“</span>' : ''}
        `;

        option.addEventListener('mouseenter', () => {
            if (!isSelected) {
                option.style.background = 'rgba(255, 255, 255, 0.1)';
            }
        });

        option.addEventListener('mouseleave', () => {
            if (!isSelected) {
                option.style.background = 'transparent';
            }
        });

        option.addEventListener('click', (e) => {
            e.stopPropagation();
            selectedAIPlatformMode = mode.id;
            console.log(`âš¡ AI Platform mode set to: ${mode.label}`);

            // Show confirmation
            option.style.background = 'rgba(0, 255, 0, 0.2)';
            setTimeout(() => {
                aiPlatformModeDropdown.remove();
                aiPlatformModeDropdown = null;

                // If 'customize' mode selected, show custom input bar
                if (mode.id === 'customize') {
                    showAIPlatformCustomPromptBar();
                }
            }, 200);
        });

        aiPlatformModeDropdown.appendChild(option);
    });

    // Add to document to measure dimensions
    document.body.appendChild(aiPlatformModeDropdown);

    // Get dropdown dimensions
    const dropdownRect = aiPlatformModeDropdown.getBoundingClientRect();
    const dropdownWidth = dropdownRect.width;
    const dropdownHeight = dropdownRect.height;

    // Get viewport dimensions
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    // Calculate optimal position
    let finalX = x;
    let finalY = y;

    // Check horizontal overflow
    if (x + dropdownWidth > viewportWidth - 10) {
        finalX = Math.max(10, x - dropdownWidth);
    }

    // Check vertical overflow
    if (y + dropdownHeight > viewportHeight - 10) {
        finalY = Math.max(10, y - dropdownHeight);
    }

    // Apply final position and make visible
    aiPlatformModeDropdown.style.left = `${finalX}px`;
    aiPlatformModeDropdown.style.top = `${finalY}px`;
    aiPlatformModeDropdown.style.visibility = 'visible';
    aiPlatformModeDropdown.style.animation = 'fadeIn 0.2s ease';

    // Close dropdown when clicking elsewhere
    const closeDropdown = (e) => {
        if (aiPlatformModeDropdown && !aiPlatformModeDropdown.contains(e.target)) {
            aiPlatformModeDropdown.remove();
            aiPlatformModeDropdown = null;
            document.removeEventListener('click', closeDropdown);
        }
    };

    setTimeout(() => {
        document.addEventListener('click', closeDropdown);
    }, 100);
}

function showAIPlatformCustomPromptBar() {
    console.log('ðŸŽ¯ showAIPlatformCustomPromptBar() called');

    // Remove any existing custom prompt bar
    if (aiPlatformCustomPromptBar) {
        console.log('ðŸ§¹ Removing existing custom prompt bar');
        aiPlatformCustomPromptBar.remove();
    }

    // Check if we have saved text (should be saved on right-click from input field)
    if (!currentAIPlatformSelectedText) {
        console.error('âŒ No saved text - text should have been saved on right-click');
        console.log('ðŸ” Fallback: currentInputField:', currentInputField);
        console.log('ðŸ” Fallback: currentInputField exists:', !!currentInputField);

        // Try to get it from input field now as fallback
        if (currentInputField) {
            currentAIPlatformSelectedText = getInputText(currentInputField);
            console.log(`ðŸ”„ Fallback: getInputText returned ${currentAIPlatformSelectedText.length} chars`);

            // If still empty, try direct access
            if (!currentAIPlatformSelectedText || currentAIPlatformSelectedText.trim().length === 0) {
                console.warn('âš ï¸ Fallback: getInputText returned empty, trying direct access');
                if (currentInputField.tagName === 'TEXTAREA' || currentInputField.tagName === 'INPUT') {
                    currentAIPlatformSelectedText = currentInputField.value;
                    console.log(`ðŸ“ Fallback: textarea/input value = ${currentAIPlatformSelectedText.length} chars`);
                } else if (currentInputField.isContentEditable || currentInputField.contentEditable === 'true') {
                    currentAIPlatformSelectedText = currentInputField.innerText || currentInputField.textContent || '';
                    console.log(`ðŸ“ Fallback: contentEditable text = ${currentAIPlatformSelectedText.length} chars`);
                }
            }
        }

        if (!currentAIPlatformSelectedText || currentAIPlatformSelectedText.trim().length === 0) {
            console.error('âŒ Still no text in input field after all fallbacks');
            console.error('ðŸ” Final currentInputField:', currentInputField);
            if (currentInputField) {
                console.error('ðŸ” Input field tagName:', currentInputField.tagName);
                console.error('ðŸ” Input field contentEditable:', currentInputField.contentEditable);
                console.error('ðŸ” Input field value:', currentInputField.value);
                console.error('ðŸ” Input field innerText:', currentInputField.innerText);
                console.error('ðŸ” Input field textContent:', currentInputField.textContent);
            }
            return;
        }
    }

    console.log(`ðŸ“ Using saved text (${currentAIPlatformSelectedText.length} chars): "${currentAIPlatformSelectedText.substring(0, 50)}..."`);

    // Get position from the input field, not selection (more stable)
    if (!currentInputField) {
        console.error('âŒ No input field found for custom prompt bar');
        return;
    }

    console.log('âœ… Input field found:', currentInputField);

    const inputRect = currentInputField.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

    // Position ABOVE the input field, left-aligned
    const barWidth = Math.min(inputRect.width * 0.6, 400);
    const barLeft = inputRect.left + scrollLeft;
    const barTop = inputRect.top + scrollTop - 48; // 48px above (height of bar + gap)

    console.log(`ðŸ“ Positioning: left=${barLeft}px, top=${barTop}px, width=${barWidth}px`);

    //Create the custom prompt bar container
    aiPlatformCustomPromptBar = document.createElement('div');
    aiPlatformCustomPromptBar.style.cssText = `
        position: absolute;
        left: ${barLeft}px;
        top: ${barTop}px;
        width: ${barWidth}px;
        min-width: 300px;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        padding: 8px 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 999999;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        animation: slideIn 0.2s ease;
    `;

    // Create input field
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'e.g., convert to technical guide, make it a tutorial...';
    input.style.cssText = `
        flex: 1;
        background: transparent;
        border: none;
        border-radius: 0;
        padding: 0;
        color: #1f2937;
        font-size: 14px;
        outline: none;
        min-width: 0;
    `;

    input.addEventListener('focus', () => {
        input.style.color = '#000';
    });

    input.addEventListener('blur', () => {
        input.style.color = '#1f2937';
    });

    // Create send button
    const sendButton = document.createElement('button');
    sendButton.innerHTML = `
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="22" y1="2" x2="11" y2="13"></line>
            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
        </svg>
    `;
    sendButton.style.cssText = `
        background: #f3f4f6;
        border: none;
        cursor: pointer;
        padding: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: all 0.15s ease;
        flex-shrink: 0;
        color: #6b7280;
    `;

    sendButton.addEventListener('mouseenter', () => {
        sendButton.style.background = '#e5e7eb';
        sendButton.style.color = '#374151';
    });

    sendButton.addEventListener('mouseleave', () => {
        sendButton.style.background = '#f3f4f6';
        sendButton.style.color = '#6b7280';
    });

    // Handle send button click
    const handleAIPlatformCustomPromptSubmit = async () => {
        const customPrompt = input.value.trim();
        if (!customPrompt) {
            // Shake animation if empty
            aiPlatformCustomPromptBar.style.animation = 'shake 0.3s ease';
            setTimeout(() => {
                aiPlatformCustomPromptBar.style.animation = 'slideIn 0.2s ease';
            }, 300);
            return;
        }

        currentAIPlatformCustomPrompt = customPrompt;
        console.log(`ðŸŽ¯ AI Platform custom prompt: ${currentAIPlatformCustomPrompt}`);

        // âœ… FIX: Save text to local variable BEFORE closing bar (which clears it)
        const savedText = currentAIPlatformSelectedText;
        console.log(`ðŸ’¾ Saved text before closing bar (${savedText ? savedText.length : 0} chars)`);

        // Close the custom prompt bar
        closeAIPlatformCustomPromptBar();

        // Show magic pill with bouncing dots loading state
        if (magicPillIcon) {
            magicPillIcon.innerHTML = `
                <div style="display: flex; gap: 3px; align-items: center; justify-content: center; height: 100%;">
                    <span style="width: 4px; height: 4px; background: #000; border-radius: 50%; animation: bounce 1.4s ease-in-out infinite;"></span>
                    <span style="width: 4px; height: 4px; background: #000; border-radius: 50%; animation: bounce 1.4s ease-in-out 0.2s infinite;"></span>
                    <span style="width: 4px; height: 4px; background: #000; border-radius: 50%; animation: bounce 1.4s ease-in-out 0.4s infinite;"></span>
                </div>
            `;
        }

        // Use the saved selected text (from local variable, not the global one that got cleared)
        if (savedText) {
            console.log(`ðŸš€ Processing with saved text (${savedText.length} chars)`);
            await proceedWithAIPlatformCustomPrompt(savedText, currentAIPlatformCustomPrompt);
        } else {
            console.error('âŒ No saved selected text found');
            showMagicPillError('No text selected');
            if (magicPillIcon) {
                magicPillIcon.innerHTML = magicPillOriginalIcon;
            }
        }
    };

    sendButton.addEventListener('click', handleAIPlatformCustomPromptSubmit);

    // Handle Enter key
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            handleAIPlatformCustomPromptSubmit();
        }
        if (e.key === 'Escape') {
            closeAIPlatformCustomPromptBar();
        }
    });

    // Append elements
    aiPlatformCustomPromptBar.appendChild(input);
    aiPlatformCustomPromptBar.appendChild(sendButton);
    document.body.appendChild(aiPlatformCustomPromptBar);

    console.log('âœ… Custom prompt bar appended to document.body');
    console.log('Bar element:', aiPlatformCustomPromptBar);
    console.log('Bar style:', aiPlatformCustomPromptBar.style.cssText);

    // Focus the input
    setTimeout(() => {
        input.focus();
        console.log('âœ… Input focused');
    }, 100);

    // Close when clicking outside
    const closeOnClickOutside = (e) => {
        if (aiPlatformCustomPromptBar && !aiPlatformCustomPromptBar.contains(e.target)) {
            closeAIPlatformCustomPromptBar();
            document.removeEventListener('click', closeOnClickOutside);
        }
    };

    setTimeout(() => {
        document.addEventListener('click', closeOnClickOutside);
    }, 100);
}

function closeAIPlatformCustomPromptBar() {
    if (aiPlatformCustomPromptBar) {
        aiPlatformCustomPromptBar.remove();
        aiPlatformCustomPromptBar = null;
    }

    // Clear saved text
    currentAIPlatformSelectedText = '';

    // Reset to default mode
    selectedAIPlatformMode = 'auto';
}

function showCustomPromptBar() {
    // Remove any existing custom prompt bar
    if (customPromptBar) {
        customPromptBar.remove();
    }

    // Hide the magic pill icon
    if (magicPillIcon) {
        magicPillIcon.style.display = 'none';
    }

    // Get the current input field (compose field)
    if (!currentInputField) {
        console.error('âŒ No input field found for custom prompt bar');
        return;
    }

    // Function to calculate and update position
    customPromptBarUpdatePosition = () => {
        const inputRect = currentInputField.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

        // Calculate width - 25% smaller than input field
        const barWidth = Math.min(inputRect.width * 0.75, 450);

        // Try to find the last line of actual text content
        let lastLineBottom = inputRect.bottom;

        try {
            // For contenteditable divs (Gmail compose)
            if (currentInputField.isContentEditable) {
                const range = document.createRange();
                const selection = window.getSelection();

                // Get all text nodes
                const textContent = currentInputField.textContent || currentInputField.innerText;

                if (textContent.trim()) {
                    // Move to the end of content
                    range.selectNodeContents(currentInputField);
                    range.collapse(false); // Collapse to end

                    // Get the rect of the cursor position at the end
                    const rects = range.getClientRects();
                    if (rects.length > 0) {
                        lastLineBottom = rects[rects.length - 1].bottom;
                    }
                }
            }
            // For textarea elements
            else if (currentInputField.tagName === 'TEXTAREA') {
                const text = currentInputField.value;
                if (text.trim()) {
                    // Create a temporary div to measure text height
                    const temp = document.createElement('div');
                    temp.style.cssText = window.getComputedStyle(currentInputField).cssText;
                    temp.style.position = 'absolute';
                    temp.style.visibility = 'hidden';
                    temp.style.height = 'auto';
                    temp.style.width = inputRect.width + 'px';
                    temp.textContent = text;
                    document.body.appendChild(temp);

                    const tempHeight = temp.offsetHeight;
                    document.body.removeChild(temp);

                    lastLineBottom = inputRect.top + tempHeight;
                }
            }
        } catch (error) {
            console.warn('Could not determine last line position:', error);
            // Fallback to input bottom
            lastLineBottom = inputRect.bottom;
        }

        if (customPromptBar) {
            customPromptBar.style.left = `${inputRect.left + scrollLeft}px`;
            customPromptBar.style.top = `${lastLineBottom + scrollTop + 2}px`;
            customPromptBar.style.width = `${barWidth}px`;
        }
    };

    // Create the custom prompt bar container - simple Claude Code style
    customPromptBar = document.createElement('div');
    customPromptBar.style.cssText = `
        position: absolute;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        padding: 8px 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 999999;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        animation: slideIn 0.2s ease;
    `;

    // Set initial position
    customPromptBarUpdatePosition();

    // Add animation styles if not present
    if (!document.querySelector('#custom-prompt-animation')) {
        const style = document.createElement('style');
        style.id = 'custom-prompt-animation';
        style.textContent = `
            @keyframes slideIn {
                from { opacity: 0; transform: translateY(-10px); }
                to { opacity: 1; transform: translateY(0); }
            }
        `;
        document.head.appendChild(style);
    }

    // Create input field - simple Claude Code style
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'e.g., remove spammy words, make it urgent...';
    input.style.cssText = `
        flex: 1;
        background: transparent;
        border: none;
        border-radius: 0;
        padding: 0;
        color: #1f2937;
        font-size: 14px;
        outline: none;
        min-width: 0;
    `;

    // Input focus styling - minimal
    input.addEventListener('focus', () => {
        input.style.color = '#000';
    });

    input.addEventListener('blur', () => {
        input.style.color = '#1f2937';
    });

    // Create send button with icon - simple Claude Code style
    const sendButton = document.createElement('button');
    sendButton.innerHTML = `
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="22" y1="2" x2="11" y2="13"></line>
            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
        </svg>
    `;
    sendButton.style.cssText = `
        background: #f3f4f6;
        border: none;
        cursor: pointer;
        padding: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: all 0.15s ease;
        flex-shrink: 0;
        color: #6b7280;
    `;

    // Send button hover effect - simple
    sendButton.addEventListener('mouseenter', () => {
        sendButton.style.background = '#e5e7eb';
        sendButton.style.color = '#374151';
    });

    sendButton.addEventListener('mouseleave', () => {
        sendButton.style.background = '#f3f4f6';
        sendButton.style.color = '#6b7280';
    });

    // Handle send button click
    const handleCustomPromptSubmit = async () => {
        const customPrompt = input.value.trim();
        if (!customPrompt) {
            // Shake animation if empty
            customPromptBar.style.animation = 'shake 0.3s ease';
            setTimeout(() => {
                customPromptBar.style.animation = 'slideIn 0.2s ease';
            }, 300);
            return;
        }

        currentCustomPrompt = customPrompt;
        console.log(`ðŸŽ¯ Custom prompt: ${currentCustomPrompt}`);

        // Close the custom prompt bar
        closeCustomPromptBar();

        // Show magic pill with bouncing dots loading state (same as other options)
        if (magicPillIcon) {
            magicPillIcon.style.display = 'block';
            magicPillIcon.innerHTML = `
                <div style="display: flex; gap: 3px; align-items: center; justify-content: center; height: 100%;">
                    <span style="width: 4px; height: 4px; background: #000; border-radius: 50%; animation: bounce 1.4s ease-in-out infinite;"></span>
                    <span style="width: 4px; height: 4px; background: #000; border-radius: 50%; animation: bounce 1.4s ease-in-out 0.2s infinite;"></span>
                    <span style="width: 4px; height: 4px; background: #000; border-radius: 50%; animation: bounce 1.4s ease-in-out 0.4s infinite;"></span>
                </div>
            `;
        }

        // Trigger enhancement with custom prompt
        const text = getInputText(currentInputField);
        if (text.trim()) {
            await proceedWithMagicPill(text, 'gmail', 'prompt', currentCustomPrompt);
        }
    };

    sendButton.addEventListener('click', handleCustomPromptSubmit);

    // Handle Enter key
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            handleCustomPromptSubmit();
        }
        if (e.key === 'Escape') {
            closeCustomPromptBar();
        }
    });

    // Add shake animation style
    if (!document.querySelector('#shake-animation')) {
        const style = document.createElement('style');
        style.id = 'shake-animation';
        style.textContent = `
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-5px); }
                75% { transform: translateX(5px); }
            }
        `;
        document.head.appendChild(style);
    }

    // Append elements
    customPromptBar.appendChild(input);
    customPromptBar.appendChild(sendButton);
    document.body.appendChild(customPromptBar);

    // Focus the input
    setTimeout(() => input.focus(), 100);

    // Monitor resize and position changes for Gmail full screen mode
    customPromptBarObserver = new ResizeObserver(() => {
        customPromptBarUpdatePosition();
    });

    // Observe the compose field for size changes
    if (currentInputField) {
        customPromptBarObserver.observe(currentInputField);
    }

    // Also update on scroll and window resize
    window.addEventListener('scroll', customPromptBarUpdatePosition, true);
    window.addEventListener('resize', customPromptBarUpdatePosition);

    // Close when clicking outside
    const closeOnClickOutside = (e) => {
        if (customPromptBar && !customPromptBar.contains(e.target)) {
            closeCustomPromptBar();
            document.removeEventListener('click', closeOnClickOutside);
        }
    };

    setTimeout(() => {
        document.addEventListener('click', closeOnClickOutside);
    }, 100);
}

function closeCustomPromptBar() {
    if (customPromptBar) {
        customPromptBar.remove();
        customPromptBar = null;
    }

    // Clean up resize observer
    if (customPromptBarObserver) {
        customPromptBarObserver.disconnect();
        customPromptBarObserver = null;
    }

    // Remove event listeners
    if (customPromptBarUpdatePosition) {
        window.removeEventListener('scroll', customPromptBarUpdatePosition, true);
        window.removeEventListener('resize', customPromptBarUpdatePosition);
        customPromptBarUpdatePosition = null;
    }

    // Show the magic pill icon again
    if (magicPillIcon) {
        magicPillIcon.style.display = 'block';
    }

    // Reset to default mode
    selectedEmailMode = 'balanced';
}

async function handleMagicPillClick(e) {  // Remove tone parameter
    e.preventDefault();
    e.stopPropagation();
    
    // Rest of the existing code...
    
    // When calling proceedWithMagicPill, pass the tone
    const platform = detectAIPlatform();
    if (platform === 'gmail') {
        proceedWithMagicPill(text, platform, tone);
    } else {
        proceedWithMagicPill(text, platform);
    }
}

// Updated proceedWithMagicPill to accept originalHTML as parameter
async function proceedWithMagicPill(text, platform = null, tone = 'balanced', customPrompt = '') {
    if (!platform) {
        platform = detectAIPlatform();
    }

    try {
        let requestData;

        // Special handling for Gmail with tone support
        if (platform === 'gmail') {
            const emailContext = extractGmailContext();

            // Check if custom prompt mode
            if (tone === 'prompt' && customPrompt) {
                requestData = {
                    type: 'gmail_enhance_custom',
                    data: {
                        text: text,
                        platform: 'gmail',
                        context: emailContext,
                        customPrompt: customPrompt
                    }
                };
            } else {
                requestData = {
                    type: 'gmail_enhance',
                    data: {
                        text: text,
                        platform: 'gmail',
                        context: emailContext,
                        mode: tone || 'balanced' // Pass the selected mode (parameter name stays 'tone' for compatibility
                    }
                };
            }


        } else {
            // Regular AI platform enhancement
            requestData = {
                type: 'magic_pill_enhance',
                data: {
                    text: text,
                    platform: platform
                }
            };
        }

        // Debug logging
        console.log('ðŸ“¤ Sending request to background:', {
            type: requestData.type,
            textLength: text.length,
            customPrompt: customPrompt || 'N/A',
            platform: platform
        });

        const response = await new Promise((resolve, reject) => {
            chrome.runtime.sendMessage(requestData, response => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    console.log('ðŸ“¥ Response from background:', response);
                    resolve(response);
                }
            });
        });
        
        if (response && response.success && response.data) {
            const enhancedText = response.data.prompt || response.data.email;


            // Replace the text in the input field
            setInputText(currentInputField, enhancedText);

            // Success animation
            magicPillIcon.style.background = '#00ff00';
            magicPillIcon.innerHTML = `
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#000" stroke-width="2.5">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
            `;

            setTimeout(() => {
                magicPillIcon.style.background = '#ffff00';
                magicPillIcon.innerHTML = magicPillOriginalIcon;
                hideMagicPill();
            }, 1500);

        } else {
            // Handle error response from background script
            const errorMessage = response?.error || 'Failed to enhance text';
            console.error('âŒ Enhancement failed:', errorMessage, response);
            throw new Error(errorMessage);
        }

    } catch (error) {
        console.error('âŒ Magic pill error:', error.message || error);
        showMagicPillError(error.message || 'Enhancement failed');
        magicPillIcon.innerHTML = magicPillOriginalIcon;
    }
}

// Extract magic pill processing logic
async function handleMagicPillClick(e) {  // Remove tone parameter
    e.preventDefault();
    e.stopPropagation();
    
    if (!currentInputField) return;
    
    const text = getInputText(currentInputField);
    if (!text.trim()) return;
    
    // START ANIMATION IMMEDIATELY
    magicPillIcon.innerHTML = `
    <div style="display: flex; gap: 3px; align-items: center; justify-content: center; height: 100%;">
        <span style="width: 4px; height: 4px; background: #000; border-radius: 50%; animation: bounce 1.4s ease-in-out infinite;"></span>
        <span style="width: 4px; height: 4px; background: #000; border-radius: 50%; animation: bounce 1.4s ease-in-out 0.2s infinite;"></span>
        <span style="width: 4px; height: 4px; background: #000; border-radius: 50%; animation: bounce 1.4s ease-in-out 0.4s infinite;"></span>
    </div>
    `;
    
    // Rate limiting check
    const now = Date.now();
    if (now - lastMagicPillClick < MAGIC_PILL_COOLDOWN) {
        magicPillIcon.innerHTML = magicPillOriginalIcon;
        showMagicPillError('Please wait a moment...');
        return;
    }
    lastMagicPillClick = now;
    
    const platform = detectAIPlatform();

    if (platform === 'gmail') {

    }
    
    // Check credits
    const creditCheck = await checkCreditsWithWarnings('magic_pill_enhance');
    
    if (!creditCheck.success) {

        magicPillIcon.innerHTML = magicPillOriginalIcon;
        
        // Show login/upgrade prompt logic
        const wasHidden = button.style.display === 'none';
        if (wasHidden) {
            button.style.display = 'block';
        }
        
        const buttonRect = button.getBoundingClientRect();
        solthronContainer.style.display = 'block';
        solthronContainer.style.pointerEvents = 'auto';
        positionContainer(buttonRect);
        
        if (wasHidden) {
            button.style.display = 'none';
        }
        
        if (creditCheck.showUpgrade) {
            showError(creditCheck.message + ' Click "Get More Credits" to purchase.');
        } else {
            showError(creditCheck.message || "Please login to use this feature");
            closeAllSections();
            const profileView = shadowRoot.getElementById('profile-view');
            const profileBtn = shadowRoot.getElementById('profile-btn');
            const outputContainer = shadowRoot.querySelector('.output-container');
            
            profileView.style.display = 'block';
            outputContainer.style.display = 'none';
            profileBtn.querySelector('svg').style.stroke = '#00ff00';
        }
        
        return;
    }
    
    // Handle low credits warning
    if (creditCheck.showWarning) {

        magicPillIcon.innerHTML = magicPillOriginalIcon;
        
        const creditsAfter = creditCheck.availableCredits - creditCheck.requiredCredits;
        showLowCreditWarning(creditCheck.warningMessage, creditsAfter);
        
        const checkUserDecision = () => {
            if (window.solthronProceedWithLowCredits === true) {
                window.solthronProceedWithLowCredits = null;
                magicPillIcon.innerHTML = `
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#000" stroke-width="2.5" class="spinning">
                        <path d="M21 12a9 9 0 11-6.219-8.56"></path>
                    </svg>
                `;
                // Pass platform and mode when user confirms
                if (platform === 'gmail') {
                    proceedWithMagicPill(text, platform, selectedEmailMode);
                } else {
                    // AI platforms: handle selected mode
                    proceedWithAIPlatformMode(text, platform, selectedAIPlatformMode);
                }
            } else if (window.solthronProceedWithLowCredits === false) {
                window.solthronProceedWithLowCredits = null;
            } else {
                setTimeout(checkUserDecision, 100);
            }
        };
        
        checkUserDecision();
        return;
    }
    
    // Proceed with enhancement - use selected mode
    if (platform === 'gmail') {
        proceedWithMagicPill(text, platform, selectedEmailMode);
    } else {
        // AI platforms: handle selected mode
        proceedWithAIPlatformMode(text, platform, selectedAIPlatformMode);
    }

}

async function proceedWithAIPlatformMode(text, platform, mode) {
    console.log(`âš¡ Processing with mode: ${mode}`);

    try {
        let requestData;

        if (mode === 'auto') {
            // Auto mode: use magic_pill_enhance
            requestData = {
                type: 'magic_pill_enhance',
                data: {
                    text: text,
                    platform: platform
                }
            };
        } else if (mode === 'convert_balanced') {
            // Convert to balanced prompt
            requestData = {
                type: 'convert_balanced',
                data: {
                    text: text,
                    platform: platform
                }
            };
        } else {
            // Customize mode should not reach here (handled by custom prompt bar)
            console.warn('Customize mode should be handled by custom prompt bar');
            return;
        }

        console.log('ðŸ“¤ Sending request to background:', {
            type: requestData.type,
            textLength: text.length,
            platform: platform
        });

        const response = await new Promise((resolve, reject) => {
            chrome.runtime.sendMessage(requestData, response => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    console.log('ðŸ“¥ Response from background:', response);
                    resolve(response);
                }
            });
        });

        if (response && response.success && response.data) {
            const enhancedText = response.data.prompt || response.data.converted_prompt || response.data.text;

            // Replace the text in the input field
            setInputText(currentInputField, enhancedText);

            // Success animation
            magicPillIcon.style.background = '#00ff00';
            magicPillIcon.innerHTML = `
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#000" stroke-width="2.5">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
            `;

            setTimeout(() => {
                magicPillIcon.style.background = '#ffff00';
                magicPillIcon.innerHTML = magicPillOriginalIcon;
                hideMagicPill();
            }, 1500);

        } else {
            const errorMessage = response?.error || 'Failed to process text';
            console.error('âŒ Processing failed:', errorMessage, response);
            throw new Error(errorMessage);
        }

    } catch (error) {
        console.error('âŒ AI Platform mode error:', error.message || error);
        showMagicPillError(error.message || 'Processing failed');
        magicPillIcon.innerHTML = magicPillOriginalIcon;
    }
}

async function proceedWithAIPlatformCustomPrompt(text, customPrompt) {
    console.log(`ðŸŽ¯ Processing with custom prompt: ${customPrompt}`);

    try {
        const requestData = {
            type: 'ai_platform_custom',
            data: {
                text: text,
                customPrompt: customPrompt
            }
        };

        console.log('ðŸ“¤ Sending custom prompt request:', {
            textLength: text.length,
            customPrompt: customPrompt
        });

        const response = await new Promise((resolve, reject) => {
            chrome.runtime.sendMessage(requestData, response => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    console.log('ðŸ“¥ Response from background:', response);
                    resolve(response);
                }
            });
        });

        if (response && response.success && response.data) {
            const enhancedText = response.data.converted_prompt || response.data.prompt || response.data.text;

            // Replace the text in the input field
            setInputText(currentInputField, enhancedText);

            // Success animation
            magicPillIcon.style.background = '#00ff00';
            magicPillIcon.innerHTML = `
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#000" stroke-width="2.5">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
            `;

            setTimeout(() => {
                magicPillIcon.style.background = '#ffff00';
                magicPillIcon.innerHTML = magicPillOriginalIcon;
                hideMagicPill();
            }, 1500);

        } else {
            const errorMessage = response?.error || 'Failed to process custom prompt';
            console.error('âŒ Custom prompt failed:', errorMessage, response);
            throw new Error(errorMessage);
        }

    } catch (error) {
        console.error('âŒ Custom prompt error:', error.message || error);
        showMagicPillError(error.message || 'Custom prompt failed');
        magicPillIcon.innerHTML = magicPillOriginalIcon;
    }
}

function showMagicPillError(message) {

    magicPillIcon.style.background = '#ff6b6b';
    setTimeout(() => {
        magicPillIcon.style.background = '#ffff00';
        // Ensure icon is reset to original
        if (magicPillIcon && magicPillOriginalIcon) {
            magicPillIcon.innerHTML = magicPillOriginalIcon;
        }
    }, 1000);
}

function removeMagicPill() {
    if (magicPillIcon) {
        magicPillIcon.remove();
        magicPillIcon = null;
    }
    
    if (currentInputField) {
        currentInputField.removeEventListener('input', handleInputChange);
        currentInputField.removeEventListener('focus', handleInputFocus);
        currentInputField.removeEventListener('blur', handleInputBlur);
        currentInputField.removeEventListener('keyup', handleCursorMove);
        currentInputField.removeEventListener('click', handleCursorMove);
        currentInputField.removeEventListener('keydown', handleKeyboardShortcut);
        
        // âœ… NEW: Remove autocomplete listeners
        currentInputField.removeEventListener('keydown', handleAutocompleteKeydown);
        currentInputField.removeEventListener('input', handleAutocompleteInput);
        currentInputField.removeEventListener('keydown', handleQuickSave);
        
        currentInputField = null;
    }
    
    // âœ… NEW: Hide autocomplete dropdown
    hideAutocompleteDropdown();
}

// ========== @MENTIONS AUTOCOMPLETE SYSTEM ==========

async function searchSavedItems(query) {
    try {
        const prompts = await loadPrompts();
        const workflows = await loadWorkflows();
        
        const allItems = [
            ...prompts.map(p => ({...p, type: 'prompt', icon: 'ðŸ“', category: 'Prompt'})),
            ...workflows.map(w => ({
                ...w, 
                type: 'workflow', 
                icon: 'âš™ï¸', 
                category: 'Workflow',
                text: w.title // Use title for searching
            }))
        ];
        
        if (!query) {
            return allItems.slice(0, 8); // Show first 8 if no query
        }
        
        // Fuzzy search
        return allItems.filter(item => {
            // Search in title for all items
            if (item.title && item.title.toLowerCase().includes(query.toLowerCase())) {
                return true;
            }
            // Search in text for prompts
            if (item.text && item.text.toLowerCase().includes(query.toLowerCase())) {
                return true;
            }
            // Search in workflow steps
            if (item.steps) {
                return item.steps.some(step => 
                    step.prompt.toLowerCase().includes(query.toLowerCase())
                );
            }
            return false;
        }).slice(0, 8); // Max 8 results
        
    } catch (error) {
        console.error('Error searching saved items:', error);
        return [];
    }
}

function createAutocompleteDropdown() {
    if (autocompleteDropdown) {
        autocompleteDropdown.remove();
    }
    
    autocompleteDropdown = document.createElement('div');
    autocompleteDropdown.id = 'solthron-autocomplete';
    autocompleteDropdown.style.cssText = `
        position: absolute;
        background: #2a2a2a;
        border: 2px solid rgba(255, 215, 0, 0.4);
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        max-height: 280px;
        overflow-y: auto;
        z-index: 9999999;
        min-width: 300px;
        display: none;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;
    
    // Add scrollbar styling
    const style = document.createElement('style');
    style.textContent = `
        #solthron-autocomplete::-webkit-scrollbar {
            width: 6px;
        }
        #solthron-autocomplete::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        #solthron-autocomplete::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.3);
            border-radius: 3px;
        }
        #solthron-autocomplete::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.5);
        }
    `;
    document.head.appendChild(style);
    
    document.body.appendChild(autocompleteDropdown);
    return autocompleteDropdown;
}

function renderAutocompleteItems(matches) {
    if (!autocompleteDropdown) {
        createAutocompleteDropdown();
    }
    
    autocompleteDropdown.innerHTML = '';
    
    if (matches.length === 0) {
        const emptyState = document.createElement('div');
        emptyState.style.cssText = `
            padding: 12px;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            font-size: 12px;
        `;
        emptyState.textContent = 'No saved items found';
        autocompleteDropdown.appendChild(emptyState);
        return;
    }
    
    matches.forEach((item, index) => {
        const option = document.createElement('div');
        option.className = 'autocomplete-option';
        option.dataset.index = index;
        
        const isSelected = index === selectedAutocompleteIndex;
        
        option.style.cssText = `
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid ${isSelected ? '#ffd700' : 'transparent'};
            background: ${isSelected ? 'rgba(255, 215, 0, 0.1)' : 'transparent'};
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        
        option.innerHTML = `
            <span style="font-size: 16px; flex-shrink: 0;">${item.icon}</span>
            <div style="flex: 1; overflow: hidden;">
                <div style="
                    color: rgba(255, 255, 255, 0.9);
                    font-size: 13px;
                    font-weight: 500;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                ">${item.title}</div>
                <div style="
                    color: rgba(255, 255, 255, 0.5);
                    font-size: 11px;
                    margin-top: 2px;
                ">${item.category}</div>
            </div>
            <div style="
                color: rgba(255, 215, 0, 0.6);
                font-size: 11px;
                flex-shrink: 0;
            ">â†µ</div>
        `;
        
        option.addEventListener('mouseenter', () => {
            selectedAutocompleteIndex = index;
            renderAutocompleteItems(autocompleteMatches);
        });
        
        option.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('ðŸ–±ï¸ Mousedown on option:', item.title);
          insertAutocompleteItem(item);
});

        option.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('ðŸ–±ï¸ Click on option:', item.title);
          insertAutocompleteItem(item);
});
        
        autocompleteDropdown.appendChild(option);
    });
}

function positionAutocompleteDropdown() {
    if (!autocompleteDropdown || !currentInputField) return;
    
    const cursorPos = getCursorPosition(currentInputField);
    
    if (cursorPos) {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
        
        // Position below cursor
        let x = cursorPos.x + scrollLeft;
        let y = cursorPos.y + scrollTop + (cursorPos.height || 20) + 5;
        
        // Viewport boundary checks
        const dropdownWidth = 300;
        const dropdownHeight = Math.min(280, autocompleteMatches.length * 60);
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // Adjust horizontal position if needed
        if (x + dropdownWidth > viewportWidth + scrollLeft - 10) {
            x = viewportWidth + scrollLeft - dropdownWidth - 10;
        }
        
        // Adjust vertical position if needed (show above cursor if not enough space below)
        if (y + dropdownHeight > viewportHeight + scrollTop - 10) {
            y = cursorPos.y + scrollTop - dropdownHeight - 5;
        }
        
        autocompleteDropdown.style.left = `${x}px`;
        autocompleteDropdown.style.top = `${y}px`;
    } else {
        // Fallback positioning
        const rect = currentInputField.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
        
        autocompleteDropdown.style.left = `${rect.left + scrollLeft}px`;
        autocompleteDropdown.style.top = `${rect.bottom + scrollTop + 5}px`;
    }
}

async function showAutocompleteDropdown(searchTerm) {
    autocompleteMatches = await searchSavedItems(searchTerm);
    selectedAutocompleteIndex = 0;
    
    if (!autocompleteDropdown) {
        createAutocompleteDropdown();
    }
    
    renderAutocompleteItems(autocompleteMatches);
    positionAutocompleteDropdown();
    autocompleteDropdown.style.display = 'block';
}

async function showWorkflowStepDropdown(stepNumber) {
    const step = activeWorkflow[stepNumber - 1];
    
    // Create a pseudo-item for the workflow step
    autocompleteMatches = [{
        id: `workflow-step-${stepNumber}`,
        type: 'workflow-step',
        icon: 'âš™ï¸',
        title: `Step ${stepNumber}`,
        category: `${activeWorkflowName} Workflow`,
        prompt: step.prompt,
        stepNumber: stepNumber
    }];
    
    selectedAutocompleteIndex = 0;
    
    if (!autocompleteDropdown) {
        createAutocompleteDropdown();
    }
    
    renderAutocompleteItems(autocompleteMatches);
    positionAutocompleteDropdown();
    autocompleteDropdown.style.display = 'block';
}

function hideAutocompleteDropdown() {
    if (autocompleteDropdown) {
        autocompleteDropdown.style.display = 'none';
    }
    autocompleteMatches = [];
    selectedAutocompleteIndex = 0;
    lastAtPosition = -1;
}

function insertAutocompleteItem(item) {
    if (!currentInputField) {
        console.error('âŒ No currentInputField available');
        return;
    }
    
    console.log('ðŸŽ¯ Starting insertion for:', item.title);
    console.log('ðŸ“‹ Item type:', item.type);
    console.log('ðŸ”§ Input element:', currentInputField.tagName);
    
    const input = currentInputField;
    const platform = detectAIPlatform();
    
    // Get content to insert
    let contentToInsert = '';
    if (item.type === 'workflow') {
        // Reset any previous workflow and activate new one
        activeWorkflow = item.steps;
        activeWorkflowName = item.name;
        contentToInsert = item.steps[0].prompt;
        console.log(`ðŸ”„ Activated workflow: ${activeWorkflowName} (Step 1)`);
        } else if (item.type === 'workflow-step') {
        // Insert specific workflow step
        contentToInsert = item.prompt;
        console.log(`ðŸ“ Inserted step ${item.stepNumber} of ${activeWorkflowName}`);
    } else {
        contentToInsert = item.text;
    }
    
    console.log('ðŸ“ Content to insert (first 100 chars):', contentToInsert.substring(0, 100));
    
    try {
        // Get current text using your existing helper
        const currentText = getInputText(input);
        console.log('ðŸ“„ Current text length:', currentText.length);
        
        // Find the @ position
        const atIndex = currentText.lastIndexOf('@');
        console.log('ðŸ“ @ symbol found at index:', atIndex);
        
        let newText;
        if (atIndex !== -1) {
            // Find where the @mention ends (space, newline, or end of text)
            let mentionEnd = atIndex + 1;
            while (mentionEnd < currentText.length && 
                   currentText[mentionEnd] !== ' ' && 
                   currentText[mentionEnd] !== '\n') {
                mentionEnd++;
            }
            
            console.log('ðŸ“ Mention ends at index:', mentionEnd);
            
            // Build new text: before @ + content + after mention
            newText = currentText.substring(0, atIndex) + 
                     contentToInsert + 
                     currentText.substring(mentionEnd);
        } else {
            console.warn('âš ï¸ No @ found, appending to end');
            newText = currentText + '\n\n' + contentToInsert;
        }
        
        console.log('âœï¸ Setting new text (length:', newText.length, ')');
        
        // Use your existing setInputText function
        setInputText(input, newText);
        
        console.log('âœ… Text set successfully');
        
        // Force focus back to input
        setTimeout(() => {
            input.focus();
            console.log('ðŸŽ¯ Focus restored to input');
        }, 100);
        
    } catch (error) {
        console.error('âŒ Error during insertion:', error);
        console.error('Error stack:', error.stack);
    }
    
    // Hide dropdown
    hideAutocompleteDropdown();
    console.log('âœ… Insertion complete, dropdown hidden');
}

function getTextOffset(element, node, offset) {
    let textOffset = 0;
    const walker = document.createTreeWalker(
        element,
        NodeFilter.SHOW_TEXT,
        null,
        false
    );
    
    let currentNode;
    while (currentNode = walker.nextNode()) {
        if (currentNode === node) {
            return textOffset + offset;
        }
        textOffset += currentNode.textContent.length;
    }
    
    return textOffset;
}

// ========== QUICK SAVE FUNCTION (Ctrl+Shift+S) ==========
// ========== QUICK SAVE FUNCTION (Alt+S) ==========
function handleQuickSave(e) {
    // Check for Alt+S
    if (e.altKey && e.key === 's') {
        e.preventDefault();
        e.stopPropagation();
        
        // Try to get highlighted text first
        let text = window.getSelection().toString().trim();
        
        // If no highlighted text, get text from input field
        if (!text && e.target) {
            text = getInputText(e.target);
        }
        
        if (text.trim().length > 0) {
            console.log('ðŸ’¾ Quick save triggered');
            
            // Save directly to prompts
            savePrompt(text).then(success => {
                if (success) {
                    // Show visual feedback
                    showQuickSaveFeedback();
                }
            });
        } else {
            console.log('âš ï¸ No text to save');
        }
    }
}

// ========== UNIVERSAL NOTIFICATION FUNCTION ==========
function showNotification(message, type = 'success') {
    const notification = document.createElement('div');
    
    const bgColor = type === 'success' ? 'rgba(0, 255, 0, 0.9)' : 
                    type === 'error' ? 'rgba(255, 107, 107, 0.9)' :
                    'rgba(255, 215, 0, 0.9)';
    
    notification.style.cssText = `
        position: fixed;
        bottom: 80px;
        right: 20px;
        background: ${bgColor};
        color: black;
        padding: 12px 16px;
        border-radius: 6px;
        font-size: 13px;
        font-weight: 500;
        z-index: 999999;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        animation: slideIn 0.3s ease;
    `;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translateY(10px)';
        notification.style.transition = 'all 0.3s ease';
        setTimeout(() => {
            notification.remove();
        }, 300);
    }, 2500);
}

// Keep wrapper for backward compatibility
function showQuickSaveFeedback() {
    showNotification('âœ“ Saved to Prompts');
}



function handleAutocompleteKeydown(e) {
    if (!autocompleteDropdown || autocompleteDropdown.style.display === 'none') {
        return false;
    }
    
    switch(e.key) {
        case 'ArrowDown':
            e.preventDefault();
            selectedAutocompleteIndex = Math.min(
                selectedAutocompleteIndex + 1,
                autocompleteMatches.length - 1
            );
            renderAutocompleteItems(autocompleteMatches);
            
            // Scroll into view
            const selectedOption = autocompleteDropdown.querySelector(`[data-index="${selectedAutocompleteIndex}"]`);
            if (selectedOption) {
                selectedOption.scrollIntoView({ block: 'nearest' });
            }
            return true;
            
        case 'ArrowUp':
            e.preventDefault();
            selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, 0);
            renderAutocompleteItems(autocompleteMatches);
            
            // Scroll into view
            const selectedOptionUp = autocompleteDropdown.querySelector(`[data-index="${selectedAutocompleteIndex}"]`);
            if (selectedOptionUp) {
                selectedOptionUp.scrollIntoView({ block: 'nearest' });
            }
            return true;
            
        case 'Enter':
            if (autocompleteMatches.length > 0) {
                e.preventDefault();
                e.stopPropagation();
                insertAutocompleteItem(autocompleteMatches[selectedAutocompleteIndex]);
                return true;
            }
            break;
            
        case 'Escape':
            e.preventDefault();
            hideAutocompleteDropdown();
            return true;
            
        case 'Tab':
            if (autocompleteMatches.length > 0) {
                e.preventDefault();
                insertAutocompleteItem(autocompleteMatches[selectedAutocompleteIndex]);
                return true;
            }
            break;
    }
    
    return false;
}

async function handleAutocompleteInput(e) {
    const input = e.target;
    let text, cursorPos;
    
    if (input.tagName === 'TEXTAREA') {
        text = input.value;
        cursorPos = input.selectionStart;
    } else {
        text = input.innerText || input.textContent || '';
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            cursorPos = getTextOffset(input, range.startContainer, range.startOffset);
        } else {
            cursorPos = text.length;
        }
    }
    
    const textBefore = text.substring(0, cursorPos);
    
    // Check for workflow step number (@2, @3, etc.) if workflow is active
    if (activeWorkflow && activeWorkflowName) {
        const stepMatch = textBefore.match(/@(\d+)$/);
        if (stepMatch) {
            const stepNumber = parseInt(stepMatch[1]);
            if (stepNumber >= 1 && stepNumber <= activeWorkflow.length) {
                // Show dropdown with the specific step
                lastAtPosition = textBefore.lastIndexOf('@');
                await showWorkflowStepDropdown(stepNumber);
                return;
            }
        }
    }
    
    // Check for @ trigger with optional search term
    const atMatch = textBefore.match(/@([\w\s]*)$/);
    
    if (atMatch) {
        const searchTerm = atMatch[1];
        lastAtPosition = textBefore.lastIndexOf('@');
        await showAutocompleteDropdown(searchTerm);
    } else {
        hideAutocompleteDropdown();
    }
}

// BACKEND AUTH SYSTEM
const BackendAuth = {
    async getAuthToken() {
        try {
            const result = await chrome.storage.local.get(['authToken']);
            return result.authToken || null;
        } catch (error) {
            console.error('Error getting auth token:', error);
            return null;
        }
    },

    async setAuthToken(token) {
        try {
            await chrome.storage.local.set({ 
                authToken: token,
                authTimestamp: Date.now()
            });
            return true;
        } catch (error) {
            console.error('Error setting auth token:', error);
            return false;
        }
    },

    async isLoggedIn() {
        try {
            const token = await this.getAuthToken();
            if (!token) return false;

            const response = await fetch('https://afaque.pythonanywhere.com/user-credits', {
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                }
            });

            return response.ok;
        } catch (error) {
            console.error('Error checking login status:', error);
            return false;
        }
    },

    async login(email, password) {
        try {
            const response = await fetch('https://afaque.pythonanywhere.com/auth/login', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ email, password })
            });

            const data = await response.json();

            if (response.ok && data.success) {
                await this.setAuthToken(data.token);
                return { success: true, user: data.user };
            } else {
                return { success: false, error: data.error || 'Login failed' };
            }
        } catch (error) {
            console.error('Login error:', error);
            return { success: false, error: 'Network error' };
        }
    },

    async logout() {
        try {
            await chrome.storage.local.remove(['authToken', 'authTimestamp']);
            pageCredits = null;
            return true;
        } catch (error) {
            console.error('Logout error:', error);
            return false;
        }
    },

    async getUserCredits() {
        try {
            const token = await this.getAuthToken();
            if (!token) return 0;

            const response = await fetch('https://afaque.pythonanywhere.com/user-credits', {
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const data = await response.json();
                return data.credits || 0;
            }
            return 0;
        } catch (error) {
            console.error('Error getting user credits:', error);
            return 0;
        }
    },

    async deductCredits(feature) {
        try {
            const token = await this.getAuthToken();
            if (!token) {
                return { success: false, message: "Not logged in" };
            }

            const response = await fetch('https://afaque.pythonanywhere.com/deduct-credits', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ feature })
            });

            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error deducting credits:', error);
            return { success: false, message: error.message };
        }
    }
};

// Storage functions

async function savePrompt(promptText) {
    // âœ… Check if a prompt is starred/active (append mode)
    if (isPromptStarActive && activePromptId) {
        try {
            const data = await chrome.storage.sync.get('savedPrompts');
            const savedPrompts = data.savedPrompts || [];
            const promptIndex = savedPrompts.findIndex(prompt => prompt.id === activePromptId);
            
            if (promptIndex !== -1) {
                // Append to existing prompt
                savedPrompts[promptIndex].text += '\n\n' + promptText;
                savedPrompts[promptIndex].timestamp = new Date().toISOString();
                await chrome.storage.sync.set({ savedPrompts });
                return true;
            }
        } catch (error) {
            console.error('Error appending to prompt:', error);
            return false;
        }
    } else {
        // Create new prompt
        const promptId = Date.now().toString();
        const title = generateTitleFromText(promptText);
        
        const prompt = {
            id: promptId,
            title: title,
            text: promptText,
            timestamp: new Date().toISOString()
        };
        
        try {
            const data = await chrome.storage.sync.get('savedPrompts');
            const savedPrompts = data.savedPrompts || [];
            savedPrompts.push(prompt);
            await chrome.storage.sync.set({ savedPrompts });
            return true;
        } catch (error) {
            console.error('Error saving prompt:', error);
            return false;
        }
    }
}

// âœ… NEW: Helper function to generate title from text
function generateTitleFromText(text) {
    if (!text || !text.trim()) {
        return 'Untitled';
    }
    
    // Remove extra whitespace and newlines
    const cleanText = text.trim().replace(/\s+/g, ' ');
    
    // Try to get first line/sentence
    let title = cleanText.split('\n')[0]; // First line
    if (!title) {
        title = cleanText.split('.')[0]; // First sentence
    }
    if (!title) {
        title = cleanText; // Fallback to full text
    }
    
    // Limit to 50 characters and break at word boundary
    if (title.length > 50) {
        title = title.substring(0, 50);
        const lastSpace = title.lastIndexOf(' ');
        if (lastSpace > 20) {
            title = title.substring(0, lastSpace);
        }
        title = title.trim() + '...';
    }
    
    return title;
}

// ========== DETECT CODE IN TEXT ==========
function detectCode(text) {
    if (!text) return false;
    
    // Check for code indicators
    const codeIndicators = [
        '```',           // Code blocks
        'function',      // JavaScript
        'def ',          // Python
        'class ',        // OOP
        'import ',       // Imports
        'const ',        // JS const
        'let ',          // JS let
        '<div',          // HTML
        'SELECT ',       // SQL
        '{',             // JSON/Objects
    ];
    
    return codeIndicators.some(indicator => text.includes(indicator));
}

// ========== DETECT PROGRAMMING LANGUAGE ==========
function detectLanguage(text) {
    if (!text) return null;
    
    // Check for code block with language
    const codeBlockMatch = text.match(/```(\w+)/);
    if (codeBlockMatch) {
        return codeBlockMatch[1];
    }
    
    // Heuristic detection
    if (text.includes('def ') && text.includes(':')) return 'python';
    if (text.includes('function') || text.includes('const ')) return 'javascript';
    if (text.includes('public class')) return 'java';
    if (text.includes('<?php')) return 'php';
    if (text.includes('<html') || text.includes('<div')) return 'html';
    if (text.includes('SELECT') && text.includes('FROM')) return 'sql';
    
    return null;
}

async function loadPrompts() {
    try {
        const data = await chrome.storage.sync.get('savedPrompts');
        let savedPrompts = data.savedPrompts || [];
        
        // âœ… NEW: Migration - Add titles to old prompts that don't have them
        let needsUpdate = false;
        savedPrompts = savedPrompts.map(prompt => {
            if (!prompt.title) {
                prompt.title = generateTitleFromText(prompt.text);
                needsUpdate = true;
            }
            return prompt;
        });
        
        // Save migrated prompts back to storage
        if (needsUpdate) {
            await chrome.storage.sync.set({ savedPrompts });
            console.log('âœ… Migrated', savedPrompts.length, 'prompts to new title format');
        }
        
        return savedPrompts;
    } catch (error) {
        console.error('Error loading prompts:', error);
        return [];
    }
}

async function loadWorkflows() {
    const builtInWorkflows = [
        {
            id: 'workflow-blogwriter',
            name: 'BlogWriter',
            title: 'Blog Writer Workflow',
            steps: [
                { number: 1, prompt: 'Write a blog article about AI trends' },
                { number: 2, prompt: 'Add some real life stories' },
                { number: 3, prompt: 'Add SEO keywords' },
                { number: 4, prompt: 'Make it easy to read and use simple english' },
                { number: 5, prompt: 'Add a catchy title and meta description' }
            ],
            timestamp: new Date().toISOString(),
            source: 'built_in'
        },
        {
            id: 'workflow-emailresponder',
            name: 'EmailResponder',
            title: 'Email Response Workflow',
            steps: [
                { number: 1, prompt: 'Read the email and understand the main points' },
                { number: 2, prompt: 'Draft a professional response addressing all concerns' },
                { number: 3, prompt: 'Add a friendly greeting and closing' },
                { number: 4, prompt: 'Proofread for tone and clarity' }
            ],
            timestamp: new Date().toISOString(),
            source: 'built_in'
        }
    ];
    
    try {
        const storageData = await chrome.storage.local.get('workflows');
        const savedWorkflows = storageData.workflows || [];
        return [...builtInWorkflows, ...savedWorkflows];
    } catch (error) {
        console.error('Error loading workflows:', error);
        return builtInWorkflows;
    }
}


async function deletePrompt(promptId) {
    try {
        const data = await chrome.storage.sync.get('savedPrompts');
        const savedPrompts = (data.savedPrompts || []).filter(p => p.id !== promptId);
        await chrome.storage.sync.set({ savedPrompts });
        return true;
    } catch (error) {
        console.error('Error deleting prompt:', error);
        return false;
    }
}



async function deleteWorkflow(workflowId) {
    try {
        const data = await chrome.storage.local.get('workflows');
        const workflows = (data.workflows || []).filter(w => w.id !== workflowId);
        await chrome.storage.local.set({ workflows });
        return true;
    } catch (error) {
        console.error('Error deleting workflow:', error);
        return false;
    }
}

// ========== SAVE CHAT EXCHANGE ==========
async function saveChatExchange(exchangeData) {
    // âœ… Check if a chat is starred/active (append mode)
    if (isChatStarActive && activeChatId) {
        try {
            const data = await chrome.storage.local.get('savedChats');
            const savedChats = data.savedChats || [];
            const chatIndex = savedChats.findIndex(chat => chat.id === activeChatId);
            
            if (chatIndex !== -1) {
                // Append to existing chat in Q&A format
                const newExchange = `\n\n---\n\nQ: ${exchangeData.question}\nA: ${exchangeData.answer}`;
                
                // Check if the original format is Q&A style or old format
                const isOldFormat = !savedChats[chatIndex].question.startsWith('Q: ');
                
                if (isOldFormat) {
                    // Convert old format to new Q&A format
                    savedChats[chatIndex].question = `Q: ${savedChats[chatIndex].question}\nA: ${savedChats[chatIndex].answer}`;
                    savedChats[chatIndex].answer = ''; // Clear answer field (no longer needed)
                }
                
                // Append new exchange
                savedChats[chatIndex].question += newExchange;
                
                // Update metadata
                savedChats[chatIndex].date = new Date().toISOString(); // Update timestamp
                // Keep original chatLink (Option A from before)
                
                // Update detection flags
                savedChats[chatIndex].hasCode = savedChats[chatIndex].hasCode || exchangeData.hasCode;
                if (exchangeData.language && !savedChats[chatIndex].language) {
                    savedChats[chatIndex].language = exchangeData.language;
                }
                
                await chrome.storage.local.set({ savedChats });
                console.log('âœ… Appended to chat:', savedChats[chatIndex].title);
                return true;
            }
        } catch (error) {
            console.error('âŒ Error appending to chat:', error);
            return false;
        }
    } else {
        // Create new chat in Q&A format
        try {
            const data = await chrome.storage.local.get('savedChats');
            const savedChats = data.savedChats || [];
            
            // âœ… Format new chats in Q&A style
            const formattedData = {
                ...exchangeData,
                question: `Q: ${exchangeData.question}\nA: ${exchangeData.answer}`,
                answer: '' // Empty since we're storing both in question field
            };
            
            savedChats.push(formattedData);
            
            await chrome.storage.local.set({ savedChats });
            
            console.log('âœ… Chat exchange saved:', formattedData.title);
            return true;
        } catch (error) {
            console.error('âŒ Error saving chat exchange:', error);
            return false;
        }
    }
}

// ========== LOAD SAVED CHATS ==========
async function loadSavedChats() {
    try {
        const data = await chrome.storage.local.get('savedChats');
        return data.savedChats || [];
    } catch (error) {
        console.error('Error loading saved chats:', error);
        return [];
    }
}

// ========== DELETE SAVED CHAT ==========
async function deleteSavedChat(chatId) {
    try {
        const data = await chrome.storage.local.get('savedChats');
        const savedChats = (data.savedChats || []).filter(c => c.id !== chatId);
        await chrome.storage.local.set({ savedChats });
        return true;
    } catch (error) {
        console.error('Error deleting chat:', error);
        return false;
    }
}

// ========== RENAME SAVED CHAT ==========
async function renameSavedChat(chatId, newTitle) {
    try {
        const data = await chrome.storage.local.get('savedChats');
        const savedChats = data.savedChats || [];
        const chatIndex = savedChats.findIndex(chat => chat.id === chatId);
        
        if (chatIndex !== -1) {
            savedChats[chatIndex].title = newTitle;
            savedChats[chatIndex].date = new Date().toISOString();
            await chrome.storage.local.set({ savedChats });
            return true;
        }
        return false;
    } catch (error) {
        console.error('Error renaming chat:', error);
        return false;
    }
}


async function renamePrompt(promptId, newTitle) {
    try {
        const data = await chrome.storage.sync.get('savedPrompts');
        const savedPrompts = data.savedPrompts || [];
        const promptIndex = savedPrompts.findIndex(prompt => prompt.id === promptId);
        
        if (promptIndex !== -1) {
            console.log('ðŸ” Before rename:', {
                oldTitle: savedPrompts[promptIndex].title,
                newTitle: newTitle,
                contentPreview: savedPrompts[promptIndex].text.substring(0, 50)
            });
            
            // âœ… CRITICAL: Only update title, NEVER touch text
            savedPrompts[promptIndex].title = newTitle;
            savedPrompts[promptIndex].timestamp = new Date().toISOString();
            
            console.log('âœ… After rename:', {
                title: savedPrompts[promptIndex].title,
                contentPreview: savedPrompts[promptIndex].text.substring(0, 50)
            });
            
            await chrome.storage.sync.set({ savedPrompts });
            return true;
        }
        return false;
    } catch (error) {
        console.error('Error renaming prompt:', error);
        return false;
    }
}

function extractConversation() {
    const platform = detectAIPlatform();
    let conversation = '';
    
    try {
        switch(platform) {
            case 'chatgpt':
                const chatMessages = document.querySelectorAll('[data-message-author-role]');
                if (chatMessages.length >= 2) {
                    const lastTwo = Array.from(chatMessages).slice(-2);
                    conversation = lastTwo.map(msg => {
                        const role = msg.getAttribute('data-message-author-role');
                        const text = msg.textContent.trim();
                        return `${role === 'user' ? 'User' : 'AI'}: ${text}`;
                    }).join('\n\n');
                }
                break;
                
            case 'claude':
                const claudeMessages = document.querySelectorAll('.prose, [data-testid*="message"]');
                if (claudeMessages.length >= 2) {
                    const lastTwo = Array.from(claudeMessages).slice(-2);
                    conversation = lastTwo.map((msg, idx) => {
                        const role = idx === 0 ? 'User' : 'AI';
                        return `${role}: ${msg.textContent.trim()}`;
                    }).join('\n\n');
                }
                break;
                
            case 'gemini':
                let geminiMessages = [];
                
                const messageElements = document.querySelectorAll(
                    'message-content[id*="message-content"], ' +
                    '[id*="model-response-message-content"], ' + 
                    '.model-response-text, ' +
                    '.markdown.markdown-main-panel, ' +
                    '.conversation-container .response-content'
                );
                
                if (messageElements.length > 0) {
                    geminiMessages = Array.from(messageElements).filter(el => {
                        const text = el.textContent.trim();
                        const isSubstantial = text.length > 30 && text.length < 5000;
                        const isNotSidebar = !el.closest('.side-navigation, .recent-chats, nav');
                        return isSubstantial && isNotSidebar;
                    });
                }
                
                if (geminiMessages.length < 2) {
                    const chatHistory = document.querySelector('#chat-history, .chat-history, .conversation-container');
                    if (chatHistory) {
                        const possibleMessages = chatHistory.querySelectorAll(
                            'div[class*="response"], div[class*="message"], p, .markdown'
                        );
                        geminiMessages = Array.from(possibleMessages).filter(el => {
                            const text = el.textContent.trim();
                            return text.length > 50 && text.length < 3000 && 
                                   !el.closest('button, input') &&
                                   !text.includes('Recent') &&
                                   !text.includes('New chat') &&
                                   !text.includes('Search for');
                        });
                    }
                }
                
                if (geminiMessages.length < 2) {
                    const userMessages = document.querySelectorAll('[class*="user"], .user-message, [role="user"]');
                    const aiMessages = document.querySelectorAll('[class*="model"], [class*="response"], .ai-message');
                    
                    if (userMessages.length > 0 && aiMessages.length > 0) {
                        geminiMessages = [
                            ...Array.from(userMessages).slice(-1),
                            ...Array.from(aiMessages).slice(-1)
                        ];
                    }
                }
                
                if (geminiMessages.length >= 2) {
                    const lastTwo = Array.from(geminiMessages).slice(-2);
                    conversation = lastTwo.map((msg, idx) => {
                        let text = msg.textContent.trim();
                        
                        text = text.replace(/^\s*[\d\w\-]+\s*/, '');
                        text = text.replace(/\s+/g, ' ');
                        
                        const isLikelyUser = text.length < 100 || 
                                           text.includes('?') ||
                                           idx === 0 ||
                                           msg.classList.contains('user') ||
                                           msg.closest('[class*="user"]');
                                           
                        const role = isLikelyUser ? 'User' : 'AI';
                        
                        return `${role}: ${text}`;
                    }).join('\n\n');
                }
                break;
                
            default:
                const allTextBlocks = document.querySelectorAll('p, div[class*="message"], div[class*="chat"], div[role="presentation"], [role="article"]');
                if (allTextBlocks.length > 0) {
                    const recent = Array.from(allTextBlocks)
                        .filter(block => {
                            const text = block.textContent.trim();
                            return text.length > 20 && text.length < 3000 && 
                                   !block.querySelector('input, button');
                        })
                        .slice(-4);
                    conversation = recent.map(block => block.textContent.trim()).join('\n\n');
                }
        }
    } catch (error) {
        console.error('Error extracting conversation:', error);
    }
    
    return conversation || 'Unable to extract conversation from this page.';
}

// Enhanced credit checking with container-based warnings
async function checkCreditsWithWarnings(mode) {
    try {
        const requiredCredits = getFeatureCredits(mode);
        
        if (requiredCredits === 0) {
            return { success: true, requiredCredits: 0 };
        }
        
        const isLoggedIn = await BackendAuth.isLoggedIn();
        if (!isLoggedIn) {
            return { success: false, message: "Please login to use this feature" };
        }
        
        if (pageCredits === null) {
            pageCredits = await BackendAuth.getUserCredits();
        }
        
        // âŒ INSUFFICIENT CREDITS - Block action
        if (pageCredits < requiredCredits) {
            return { 
                success: false, 
                message: `Insufficient credits. This feature requires ${requiredCredits} credits, but you have ${pageCredits}.`,
                showUpgrade: true
            };
        }
        
        // âš ï¸ LOW CREDIT WARNING - Allow action but warn user
        const creditsAfterAction = pageCredits - requiredCredits;
        
        if (creditsAfterAction <= 5) {
            return {
                success: true,
                requiredCredits: requiredCredits,
                availableCredits: pageCredits,
                showWarning: true,
                warningMessage: creditsAfterAction === 0 ? 
                    `This will use your final credit! You'll have 0 credits left after this action.` :
                    `Low credits warning: You'll have ${creditsAfterAction} credits left after this action.`
            };
        }
        
        // âœ… SUFFICIENT CREDITS - Proceed normally
        return { 
            success: true, 
            requiredCredits: requiredCredits,
            availableCredits: pageCredits
        };
        
    } catch (error) {
        console.error('Credit check error:', error);
        return { success: true }; // Fallback allows usage
    }
}

// Keep the simple wrapper for backward compatibility
async function checkCredits(mode) {
    return await checkCreditsWithWarnings(mode);
}

// Show low credit warning in container
function showLowCreditWarning(warningMessage, creditsAfter) {
    // Force show container (same logic as login)
    const wasHidden = button.style.display === 'none';
    if (wasHidden) {
        button.style.display = 'block';
    }
    
    const buttonRect = button.getBoundingClientRect();
    solthronContainer.style.display = 'block';
    solthronContainer.style.pointerEvents = 'auto';
    positionContainer(buttonRect);
    
    if (wasHidden) {
        button.style.display = 'none';
    }
    
    // Show warning view in container
    closeAllSections();
    const outputContainer = shadowRoot.querySelector('.output-container');
    outputContainer.style.display = 'block';
    
    // Create warning content
    outputText.classList.remove('placeholder', 'shimmer-loading');
    outputText.classList.add('credit-warning');
    
    const isLastCredit = creditsAfter === 0;
    const warningColor = isLastCredit ? '#ff6b6b' : '#ffa500';
    const warningIcon = isLastCredit ? 'ðŸ”¥' : 'âš ï¸';
    
    outputText.innerHTML = `
        <div style="
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid ${warningColor};
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
            text-align: center;
        ">
            <div style="
                font-size: 18px;
                margin-bottom: 8px;
            ">${warningIcon}</div>
            <div style="
                color: ${warningColor};
                font-weight: 500;
                font-size: 14px;
                margin-bottom: 8px;
            ">${isLastCredit ? 'Final Credit Warning!' : 'Low Credits Warning'}</div>
            <div style="
                color: rgba(255, 255, 255, 0.9);
                font-size: 13px;
                line-height: 1.4;
            ">${warningMessage}</div>
        </div>
        
        <div style="
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        ">
            <button id="proceed-action" style="
                background: rgba(0, 255, 0, 0.1);
                border: 1px solid rgba(0, 255, 0, 0.3);
                color: #00ff00;
                padding: 8px 12px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 13px;
                transition: all 0.2s ease;
            ">Continue with Action</button>
            
            <button id="get-credits" style="
                background: rgba(255, 215, 0, 0.1);
                border: 1px solid rgba(255, 215, 0, 0.3);
                color: #ffd700;
                padding: 8px 12px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 13px;
                transition: all 0.2s ease;
            ">Get More Credits</button>
            
            <button id="cancel-action" style="
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: rgba(255, 255, 255, 0.8);
                padding: 6px 12px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 12px;
                transition: all 0.2s ease;
            ">Cancel</button>
        </div>
    `;
    
    // Add event listeners for buttons
    shadowRoot.getElementById('proceed-action').addEventListener('click', () => {
        // Close container and proceed with original action
        solthronContainer.style.display = 'none';
        solthronContainer.style.pointerEvents = 'none';
        // Return true to indicate user wants to proceed
        window.solthronProceedWithLowCredits = true;
    });
    
    shadowRoot.getElementById('get-credits').addEventListener('click', () => {
        // Open credits purchase page
        window.open('https://solthron.com/credits', '_blank');
    });
    
    shadowRoot.getElementById('cancel-action').addEventListener('click', () => {
        // Close container and cancel action
        solthronContainer.style.display = 'none';
        solthronContainer.style.pointerEvents = 'none';
        window.solthronProceedWithLowCredits = false;
    });
}

// Display functions
function displaySmartFollowups(data) {
    hideShimmerLoading();
    outputText.classList.remove('placeholder', 'error');
    
    const platform = detectAIPlatform();
    const platformName = platform.charAt(0).toUpperCase() + platform.slice(1);
    
    let html = '<div class="smart-followups-container">';
    
    if (platform !== 'unknown') {
        html += `
            <div class="platform-indicator">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M12 6v6l4 2"></path>
                </svg>
                <span>Analyzing ${platformName} conversation</span>
            </div>
        `;
    }
    
    if (data.analysis) {
        html += `<div class="analysis-insight">${data.analysis}</div>`;
    }
    
    data.questions.forEach((question, index) => {
        html += `
            <div class="followup-card">
                <div class="followup-question">${question.text}</div>
                <button class="followup-copy-btn" data-question="${question.text.replace(/"/g, '&quot;')}">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                        <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                    </svg>
                </button>
            </div>
        `;
    });
    
    html += '</div>';
    outputText.innerHTML = html;
    
    shadowRoot.querySelectorAll('.followup-copy-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
            const question = btn.dataset.question;
            try {
                await navigator.clipboard.writeText(question);
                btn.classList.add('copied');
                
                btn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                `;
                
                setTimeout(() => {
                    btn.classList.remove('copied');
                    btn.innerHTML = `
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                            <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                        </svg>
                    `;
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
            }
        });
    });
}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}


function showError(message) {
    hideShimmerLoading();
    outputText.classList.add('error');
    outputText.textContent = message;
}

function updateOutput(text) {
    hideShimmerLoading();
    outputText.classList.remove('placeholder');
    outputText.textContent = text;
}

function isImage(element) {
    return element.tagName === 'IMG' && element.src;
}

async function processSelectedText(text) {
    if (!text.trim()) return;
    
    const buttonRect = button.getBoundingClientRect();
    solthronContainer.style.display = 'block';
    solthronContainer.style.pointerEvents = 'auto';
    positionContainer(buttonRect);
    
    // âœ… FIXED: Handle save features WITHOUT loading animation
    if (selectedMode.startsWith('save_')) {
        // Show button animation only, no loading bar
        button.querySelector('.solthron-button').textContent = '...';
        
        // Clear any existing output states
        outputText.classList.remove('placeholder', 'shimmer-loading', 'error');
        outputText.textContent = 'Saving...';
        
        let saveFunction;
        
        if (selectedMode === 'save_prompt') {
            saveFunction = savePrompt;
        }
        
        if (await saveFunction(text)) {
            button.querySelector('.solthron-button').textContent = 'âœ“';
            outputText.textContent = 'Saved successfully!';
            
            setTimeout(() => {
                button.querySelector('.solthron-button').textContent = 'âž¤';
                // Open gallery after saving
                closeAllSections();
                const galleryView = shadowRoot.getElementById('gallery-view');
                const galleryBtn = shadowRoot.getElementById('gallery-btn');
                galleryView.style.display = 'block';
                shadowRoot.querySelector('.output-container').style.display = 'none';
                galleryBtn.querySelector('svg').style.stroke = '#00ff00';
            }, 1000);
        } else {
            button.querySelector('.solthron-button').textContent = 'âœ—';
            outputText.textContent = 'Failed to save';
            setTimeout(() => {
                button.querySelector('.solthron-button').textContent = 'âž¤';
            }, 1000);
        }
        return;
    }

    // âœ… Show loading animation only for processing features
    showShimmerLoading('Processing...');

    if (selectedMode.startsWith('image_')) return;

    const creditCheck = await checkCredits(selectedMode);
    if (!creditCheck.success) {
        showError(creditCheck.message || "Please check your account status.");
        return;
    }

    handleTextProcessing(text);
}

async function handleTextProcessing(text) {
    // âœ… FIXED: Ensure proper view state when processing
    const galleryView = shadowRoot.getElementById('gallery-view');
    const outputContainer = shadowRoot.querySelector('.output-container');
    
    if (galleryView.style.display === 'block') {
        closeAllSections(); // This will show output container
    }

    showShimmerLoading('Processing...');

    try {
        const response = await new Promise((resolve, reject) => {
            chrome.runtime.sendMessage({
                type: 'enhance_text',
                data: {
                    topic: text,
                    tone: 'professional',
                    length: 'balanced',
                    mode: selectedMode
                }
            }, response => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve(response);
                }
            });
        });

        if (response && response.success) {
            let formattedOutput = response.data.prompt;
            updateOutput(formattedOutput);
            solthronContainer.style.display = 'block';
        } else {
            showError('Failed to process text');
        }
    } catch (error) {
        showError('Error processing text');
    } finally {
        button.querySelector('.solthron-button').textContent = 'âž¤';
    }
}

// âœ¨ CREATE SHADOW DOM AND UI
function createUI() {
    // Create shadow host
    const shadowHost = document.createElement('div');
    shadowHost.id = 'solthron-shadow-host';
    shadowHost.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 0 !important;
        height: 0 !important;
        z-index: 2147483647 !important;
        pointer-events: none !important;
    `;
    
    document.body.appendChild(shadowHost);
    
    // Create shadow root
    shadowRoot = shadowHost.attachShadow({ mode: 'open' });

    // âœ… ADD THIS CODE HERE:
    // Allow context menu events to propagate within shadow DOM
    shadowRoot.addEventListener('contextmenu', (e) => {
        // Allow context menu inside gallery items
        if (e.target.closest('.gallery-item')) {
            // Let the event reach the item's contextmenu handler
            return true;
        }
    }, true);// Use capture phase
    
    // CSS styles (completely isolated in shadow DOM)
    const styles = `
        <style>
        /* âœ… ISOLATED CSS - Won't affect the host page */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif !important;
            line-height: normal;
            letter-spacing: normal;
            text-transform: none;
            text-shadow: none !important;
        }

        #solthron-floating-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            pointer-events: auto;
        }

        .solthron-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #ffff00;
            border: none;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2), 0 0 20px rgba(255, 255, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            font-weight: 900;
            color: #000000;
            line-height: 1;
            padding: 0;
            transform: translateY(-1px);
        }

        .solthron-button:hover {
            box-shadow: 0 2px 5px rgba(0,0,0,0.2), 0 0 25px rgba(255, 255, 0, 0.4);
        }

        .solthron-container {
            position: fixed;
            width: 320px;
            background: #1a1a1a;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 10000;
            pointer-events: auto;
            display: none;
        }

        .solthron-content {
            padding: 12px;
            position: relative;
        }

        .solthron-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .mode-dropdown {
            position: relative;
            flex: 1;
            margin-right: 12px;
        }

        .mode-select {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px !important;
            padding: 6px 8px;
            cursor: pointer;
            -webkit-appearance: none;
            padding-right: 24px;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 12px;
            max-height: 100px;
            overflow-y: auto;
        }

        .mode-select::-webkit-scrollbar {
            width: 6px;
        }

        .mode-select::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .mode-select::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .mode-select::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .mode-select:hover {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .mode-select:focus {
            outline: none;
            border-color: rgba(255, 255, 0, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 255, 0, 0.2);
        }

        .mode-select option {
            background-color: #2a2a2a !important;
            color: rgba(255, 255, 255, 0.9);
            padding: 8px;
            font-size: 13px !important;
        }

        .mode-select optgroup {
            background: #2a2a2a;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px !important;
            font-weight: 500;
            padding: 8px 4px;
        }

        .mode-select optgroup option {
            background: #2a2a2a;
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px !important;
            padding: 8px 12px;
            margin-left: 8px;
        }

        .header-icons {
            display: flex;
            gap: 4px;
        }

        .icon-button {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: #fff;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .icon-button:hover {
            opacity: 1;
        }

        .output-container {
            position: relative;
        }

        .output-text {
            background: #2a2a2a;
            color: #fff !important;
            padding: 12px;
            border-radius: 6px;
            min-height: 60px;
            max-height: 150px;
            line-height: 1.4 !important;
            font-size: 13px !important;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .output-text.placeholder {
            color: rgba(255, 255, 255, 0.4) !important;
            font-style: italic;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .output-text.error {
            color: #ff6b6b;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }
        
        .output-text.credit-warning {
    background: #2a2a2a;
    color: #fff;
    border: none;
}

.output-text.credit-warning button:hover {
    transform: translateY(-1px);
}

.output-text.credit-warning #proceed-action:hover {
    background: rgba(0, 255, 0, 0.2) !important;
    border-color: rgba(0, 255, 0, 0.5) !important;
}

.output-text.credit-warning #get-credits:hover {
    background: rgba(255, 215, 0, 0.2) !important;
    border-color: rgba(255, 215, 0, 0.5) !important;
}

.output-text.credit-warning #cancel-action:hover {
    background: rgba(255, 255, 255, 0.1) !important;
    border-color: rgba(255, 255, 255, 0.3) !important;
}

        .output-text::-webkit-scrollbar {
            width: 6px;
        }

        .output-text::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .output-text::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .output-text::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Loading Bar Effect */
        .output-text.shimmer-loading {
            background: #2a2a2a !important;
            color: rgba(255, 255, 255, 0.8) !important;
            position: relative;
            padding-bottom: 20px !important;
        }

        .output-text.shimmer-loading::after {
            content: '';
            position: absolute;
            bottom: 8px;
            left: 12px;
            right: 12px;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .output-text.shimmer-loading::before {
            content: '';
            position: absolute;
            bottom: 8px;
            left: 12px;
            height: 3px;
            width: 30%;
            background: linear-gradient(
                90deg,
                transparent 0%,
                #ffff00 30%,
                #fff700 70%,
                transparent 100%
            );
            border-radius: 2px;
            animation: loading-sweep 1.5s infinite linear;
            z-index: 1;
            will-change: transform;
        }

        @keyframes loading-sweep {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(300%);
            }
        }

        /* Double-Click Animation */
        .solthron-button.double-click-activated {
            animation: 
                solthronBounce 0.6s ease-out,
                solthronGlow 0.6s ease-out;
        }

        @keyframes solthronBounce {
            0% { transform: scale(1) translateY(-1px); }
            15% { transform: scale(0.85) translateY(-1px); }
            35% { transform: scale(1.25) translateY(-1px); }
            55% { transform: scale(0.95) translateY(-1px); }
            75% { transform: scale(1.05) translateY(-1px); }
            100% { transform: scale(1) translateY(-1px); }
        }

        @keyframes solthronGlow {
            0% { 
                box-shadow: 
                    0 2px 5px rgba(0,0,0,0.2), 
                    0 0 20px rgba(255, 255, 0, 0.3),
                    0 0 0 0 rgba(255, 255, 0, 0.3);
            }
            40% {
                box-shadow: 
                    0 2px 5px rgba(0,0,0,0.2), 
                    0 0 25px rgba(255, 255, 0, 0.4),
                    0 0 0 8px rgba(255, 255, 0, 0.2);
            }
            70% { 
                box-shadow: 
                    0 2px 5px rgba(0,0,0,0.2), 
                    0 0 30px rgba(255, 255, 0, 0.5),
                    0 0 0 15px rgba(255, 255, 0, 0);
            }
            100% { 
                box-shadow: 
                    0 2px 5px rgba(0,0,0,0.2), 
                    0 0 20px rgba(255, 255, 0, 0.3),
                    0 0 0 0 rgba(255, 255, 0, 0);
            }
        }

        /* Magic Pill Toggle Styles - REMOVED */

        /* Gallery Styles */
        .gallery-view {
            background: #2a2a2a;
            border-radius: 6px;
            margin-top: 12px;
        }

        .gallery-header {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .gallery-header h3 {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px !important;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .gallery-search input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 6px 8px;
            color: white;
            font-size: 12px !important;
        }

        .gallery-search input:focus {
            outline: none;
            border-color: rgba(255, 255, 0, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 255, 0, 0.2);
        }

        .gallery-list {
            max-height: 153px;
            overflow-y: auto;
            padding: 8px;
        }

        .gallery-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 6px 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            height: 45px;
            overflow: hidden;
        }

        .gallery-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .gallery-item-text {
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px !important;
            line-height: 1.2;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .gallery-item-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .gallery-item:hover .gallery-item-actions {
            opacity: 1;
        }

        .gallery-copy-btn,
        .gallery-delete-btn,
        .gallery-star-btn {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.2s ease;
        }

        .gallery-star-btn:hover {
            color: rgba(255, 255, 255, 0.9);
        }

        .gallery-star-btn.active {
            color: #ffff00;
        }

        .gallery-star-btn.active svg {
            filter: drop-shadow(0 0 2px rgba(255, 255, 0, 0.5));
        }
           
        .gallery-star-btn.active svg {
            filter: drop-shadow(0 0 2px rgba(255, 255, 0, 0.5));
        }

        .gallery-rename-btn {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.2s ease;
        }

        .gallery-rename-btn:hover {
            color: rgba(255, 215, 0, 0.9);
        }

        .gallery-copy-btn,
        .gallery-delete-btn,

        .gallery-copy-btn:hover,
        .gallery-delete-btn:hover {
            color: rgba(255, 255, 255, 0.9);
        }

        .gallery-delete-btn:hover {
            color: #ff6b6b;
        }

        .gallery-copy-btn.copied {
            color: #00ff00;
        }

        .gallery-list::-webkit-scrollbar {
            width: 6px;
        }

        .gallery-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .gallery-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .gallery-list::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Category Selection */
        .category-selection {
            padding: 16px;
            margin-bottom: 8px;
        }

        .category-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .category-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .category-title {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px !important;
            font-weight: 500;
            text-align: center;
        }

        .gallery-title-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            gap: 8px;
        }

        .back-to-categories {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            transition: color 0.2s ease;
        }

        .back-to-categories:hover {
            color: rgba(255, 255, 255, 0.9);
        }

        #gallery-content {
            transition: opacity 0.2s ease;
        }

        #gallery-content.hiding {
            opacity: 0;
        }

        #gallery-content.showing {
            opacity: 1;
        }

        #gallery-btn svg {
            transition: stroke 0.2s ease;
        }

        #gallery-btn.active svg {
            stroke: #00ff00;
        }

        /* Profile Styles */
        .profile-view {
            background: #2a2a2a;
            border-radius: 6px;
            margin-top: 12px;
            max-height: 350px;
            overflow-y: auto;
        }

        .profile-header {
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .profile-header h3 {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 500;
            margin: 0;
        }

        .close-profile {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            padding: 4px;
        }

        .profile-details {
            padding: 16px;
        }

        .loading-profile {
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            padding: 20px 0;
            font-style: italic;
        }

        .profile-info {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .profile-field {
            display: flex;
            flex-direction: column;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .field-label {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            margin-bottom: 4px;
        }

        .field-value {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
        }

        .profile-field.credits {
            margin-top: 8px;
        }

        .credits .field-value {
            color: #ffff00;
            font-weight: 500;
            font-size: 16px;
        }

        .field-value-with-button {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .buy-credits-btn {
    background: #2a2a2a;
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: white;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
    box-shadow: 
        0 2px 4px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    position: relative;
}

.buy-credits-btn:hover {
    background: #333333;
    border-color: rgba(255, 255, 255, 0.3);
    box-shadow: 
        0 3px 6px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.15);
    transform: translateY(-1px);
}

.buy-credits-btn:active {
    transform: translateY(0px);
    box-shadow: 
        0 1px 2px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

        .login-prompt {
            text-align: center;
            padding: 20px 0;
        }

        .login-button, .logout-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.9);
            padding: 8px 16px;
            margin-top: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
        }

        .login-button:hover, .logout-button:hover {
            background: rgba(255, 255, 255, 0.15);
        }
         
        /* Google Auth Buttons */
        .google-auth-button {
            background: #ffffff;
            color: #424242;
            border: 1px solid #dadce0;
            border-radius: 8px;
            padding: 12px 16px;
            width: 100%;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-family: inherit;
        }

        .google-auth-button:hover {
            background: #f8f9fa;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }

        .google-auth-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Fallback Login Button */
        .fallback-login-button {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.9);
            padding: 10px 16px;
            width: 100%;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .fallback-login-button:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .logout-button {
            margin-top: 20px;
        }

        .login-form {
            padding: 10px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            margin-bottom: 4px;
        }

        .form-group input {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 13px;
        }

        .form-group input:focus {
            outline: none;
            border-color: rgba(255, 255, 0, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 255, 0, 0.2);
        }

        .form-actions {
            margin-top: 15px;
        }

        .login-button {
            background: #3c78d8;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s ease;
            width: 100%;
        }

        .login-button:hover {
            background: #4285f4;
        }

        .error-message {
            color: #ff6b6b;
            font-size: 12px;
            margin-top: 8px;
            min-height: 16px;
        }

        .signup-link {
            margin-top: 15px;
            text-align: center;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 12px;
        }

        .signup-link p {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            margin-bottom: 5px;
        }

        .signup-link a {
            color: #3c78d8;
            text-decoration: none;
            font-size: 12px;
            font-weight: 500;
        }

        .signup-link a:hover {
            text-decoration: underline;
        }

        .workflow-container::-webkit-scrollbar {
    width: 6px;
}

.workflow-container::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
}

.workflow-container::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
}

.workflow-container::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
}

/* Workflow Step Bubbles */
.workflow-step-bubble {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.12);
    border-radius: 6px;
    padding: 10px;
    display: flex;
    align-items: flex-start;
    gap: 10px;
    transition: all 0.2s ease;
    cursor: pointer;
}

.workflow-step-bubble:hover {
    background: rgba(255, 255, 255, 0.06);
    border-color: rgba(255, 215, 0, 0.25);
}

.workflow-step-bubble .step-content {
    flex: 1;
    color: rgba(255, 255, 255, 0.9);
    font-size: 12px;
    line-height: 1.5;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}

        /* Smart Followups & Actions */
        .smart-followups-container,
        .smart-actions-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 4px;
        }

        .followup-card,
        .action-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            position: relative;
            transition: all 0.2s ease;
            min-height: 50px;
            display: flex;
            align-items: center;
        }

        .followup-card:hover,
        .action-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 0, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .followup-question,
        .action-prompt {
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px !important;
            line-height: 1.4;
            padding-right: 36px;
            flex: 1;
        }

        .followup-copy-btn,
        .action-copy-btn {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.5);
            transition: all 0.2s ease;
        }

        .followup-copy-btn:hover,
        .action-copy-btn:hover {
            color: rgba(255, 255, 255, 0.8);
        }

        .followup-copy-btn.copied,
        .action-copy-btn.copied {
            color: #00ff00;
        }

        .followup-copy-btn.copied svg,
        .action-copy-btn.copied svg {
            filter: drop-shadow(0 0 3px rgba(0, 255, 0, 0.5));
        }

        .analysis-insight {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid rgba(255, 255, 0, 0.2);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px !important;
            font-style: italic;
            line-height: 1.4;
        }

        .platform-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 11px !important;
            color: rgba(255, 255, 255, 0.6);
        }

        .platform-indicator svg {
            width: 14px;
            height: 14px;
        }

        /* Smart Enhancements */

        /* Magic Pill animation */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .spinning {
            animation: spin 1s linear infinite;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes bounce {
    0%, 80%, 100% {
        transform: translateY(0) scale(1);
        opacity: 1;
    }
    40% {
        transform: translateY(-6px) scale(1.2);
        opacity: 0.7;
    }
}

        @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
}

        /* Responsive */
        @media screen and (max-width: 480px) {
            .solthron-container {
                width: 90vw;
                max-width: 320px;
            }
        }
        </style>
    `;
    
    // HTML content - UPDATED WITH MAGIC PILL TOGGLE AND REDUCED OPTIONS
    const htmlContent = `
        <div id="solthron-floating-button">
            <button class="solthron-button">âž¤</button>
        </div>
        
        <div id="solthron-container" class="solthron-container" style="display: none;">
            <div class="solthron-content"> 
                <div class="solthron-header">
                    <div class="mode-dropdown">
                        <select class="mode-select">
                            <optgroup label="Storage">
                                <option value="save_prompt">Save as Prompt</option>
                            </optgroup>
                            <optgroup label="Image">
                                <option value="image_prompt">Image to Prompt</option>
                            </optgroup>
                            <optgroup label="AI Assistant">
                                <option value="smart_followups">Smart Follow-ups</option>
                            </optgroup>
                        </select>                
                    </div>
                    <div class="header-icons">
                        <button id="profile-btn" class="icon-button">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                                <circle cx="12" cy="7" r="4"></circle>
                            </svg>
                        </button>
                        <button id="gallery-btn" class="icon-button">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="7" height="7"></rect>
                                <rect x="14" y="3" width="7" height="7"></rect>
                                <rect x="14" y="14" width="7" height="7"></rect>
                                <rect x="3" y="14" width="7" height="7"></rect>
                            </svg>
                        </button>
                        <button id="copy-btn" class="icon-button">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                                <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                            </svg>
                        </button>
                        <button id="close-btn" class="icon-button">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="output-container">
                    <div id="output-text" class="output-text placeholder">
                        Please highlight text or right-click an image to begin...
                    </div>
                </div>
                <div id="gallery-view" class="gallery-view" style="display: none;">
                <div id="category-selection" class="category-selection">
                       <div class="category-item" data-category="prompts">
                       <div class="category-title">Prompts</div>
                </div>
                <div class="category-item" data-category="chats">
                <div class="category-title">Saved Chats</div>
                </div>
                <div class="category-item" data-category="workflows">
                       <div class="category-title">Workflows</div>
                    </div>    
                </div>
                    <div id="gallery-content" style="display: none;">
                        <div class="gallery-header">
                            <div class="gallery-title-row">
                                <h3 id="gallery-title">Saved Items</h3>
                                <button class="back-to-categories">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M19 12H5"/>
                                        <path d="M12 19l-7-7 7-7"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="gallery-search">
                                <input type="text" placeholder="Search..." id="gallery-search">
                            </div>
                        </div>
                        <div class="gallery-list" id="gallery-list"></div>
                    </div>
                </div>
                <div id="profile-view" class="profile-view" style="display: none;">
                    <div class="profile-header">
                        <h3>Account</h3>
                        <button class="close-profile">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                    <div id="login-container" class="login-form">
    <!-- Login View -->
    <div id="login-view" class="auth-prompt">
        <p style="color: rgba(255, 255, 255, 0.8); text-align: center; margin-bottom: 20px; font-size: 14px;">Login to access premium features and credit management</p>
        
        <button id="google-login-btn" class="google-auth-button" style="margin-bottom: 16px;">
            <svg width="18" height="18" viewBox="0 0 24 24" style="margin-right: 10px;">
                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
            </svg>
            Login with Google
        </button>
        
        <!-- Divider -->
        <div style="display: flex; align-items: center; margin: 16px 0; opacity: 0.6;">
            <div style="flex: 1; height: 1px; background: rgba(255, 255, 255, 0.2);"></div>
            <span style="padding: 0 12px; color: rgba(255, 255, 255, 0.5); font-size: 12px;">or</span>
            <div style="flex: 1; height: 1px; background: rgba(255, 255, 255, 0.2);"></div>
        </div>
        
        <button id="login-button" class="fallback-login-button">Login via Solthron.com</button>
        
        <div style="text-align: center; margin-top: 12px;">
            <span style="color: rgba(255, 255, 255, 0.6); font-size: 13px;">Don't have an account? </span>
            <a href="#" id="show-signup" style="color: #4285F4; text-decoration: none; font-size: 13px;">Sign up</a>
        </div>
    </div>
    
    <!-- Signup View -->
    <div id="signup-view" class="auth-prompt" style="display: none;">
        <p style="color: rgba(255, 255, 255, 0.8); text-align: center; margin-bottom: 20px; font-size: 14px;">Create your account to get started</p>
        
        <button id="google-signup-btn" class="google-auth-button" style="margin-bottom: 16px;">
            <svg width="18" height="18" viewBox="0 0 24 24" style="margin-right: 10px;">
                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
            </svg>
            Sign up with Google
        </button>
        
        <!-- Divider -->
        <div style="display: flex; align-items: center; margin: 16px 0; opacity: 0.6;">
            <div style="flex: 1; height: 1px; background: rgba(255, 255, 255, 0.2);"></div>
            <span style="padding: 0 12px; color: rgba(255, 255, 255, 0.5); font-size: 12px;">or</span>
            <div style="flex: 1; height: 1px; background: rgba(255, 255, 255, 0.2);"></div>
        </div>
        
        <button id="signup-button" class="fallback-login-button">Sign up via Solthron.com</button>
        
        <div style="text-align: center; margin-top: 12px;">
            <span style="color: rgba(255, 255, 255, 0.6); font-size: 13px;">Already have an account? </span>
            <a href="#" id="show-login" style="color: #4285F4; text-decoration: none; font-size: 13px;">Login</a>
        </div>
    </div>
    
    <div id="login-error" class="error-message"></div>
</div>
                    <div id="profile-details" class="profile-details" style="display: none;">
                        <!-- Will show user details when logged in -->
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Inject styles and HTML into shadow root
    shadowRoot.innerHTML = styles + htmlContent;
    
    // Get references to elements within shadow DOM
    button = shadowRoot.querySelector('#solthron-floating-button');
    outputText = shadowRoot.querySelector('#output-text');
    solthronContainer = shadowRoot.querySelector('#solthron-container');
    
    // Initialize UI handlers and gallery
    initializeUIHandlers();
    initializeAddWorkflowFeature();
    initializeGallery();
    initializeAddPromptFeature(); // âœ… ADD THIS LINE

    // Hide button initially
    button.style.display = 'none';
}

function initializeGallery() {
    const galleryBtn = shadowRoot.getElementById('gallery-btn');
    const galleryView = shadowRoot.getElementById('gallery-view');
    const categorySelection = shadowRoot.getElementById('category-selection');
    const galleryContent = shadowRoot.getElementById('gallery-content');
    const searchInput = shadowRoot.getElementById('gallery-search');
    const outputContainer = shadowRoot.querySelector('.output-container');
 
    galleryBtn.addEventListener('click', () => {
        const isVisible = galleryView.style.display !== 'none';
        
        if (isVisible) {
            // Close gallery and show output
            closeAllSections();
        } else {
            // Close all other sections and show gallery
            closeAllSections();
            galleryView.style.display = 'block';
            outputContainer.style.display = 'none';
            galleryBtn.querySelector('svg').style.stroke = '#00ff00';
            
            // Reset to category selection
            categorySelection.style.display = 'block';
            galleryContent.style.display = 'none';
            currentCategory = null;
        }
    });
 
    shadowRoot.querySelectorAll('.category-item').forEach(item => {
    item.addEventListener('click', async () => {
        currentCategory = item.dataset.category;
        categorySelection.style.display = 'none';
        galleryContent.style.display = 'block';
        
        const galleryTitle = shadowRoot.getElementById('gallery-title');
        galleryTitle.textContent = currentCategory === 'prompts' ? 'Saved Prompts' : 
                                 currentCategory === 'chats' ? 'Saved Chats' :
                                 'Workflows';
        
        const items = await (
            currentCategory === 'prompts' ? loadPrompts() :
            currentCategory === 'chats' ? loadSavedChats() :
            loadWorkflows()
        );
        renderGalleryList(items, '');
        
        // âœ… ADD THIS: Initialize add button for prompts and workflows
        if (currentCategory === 'prompts') {
            updateGalleryHeaderWithAddButton();
        } else if (currentCategory === 'workflows') {
            updateGalleryHeaderWithAddWorkflowButton();
        }
    });
});
 
    shadowRoot.querySelector('.back-to-categories').addEventListener('click', () => {
    categorySelection.style.display = 'block';
    galleryContent.style.display = 'none';
    currentCategory = null;
    
    // âœ… ADD THIS: Remove add buttons when going back
    const addPromptBtn = shadowRoot.getElementById('add-prompt-btn');
    const addWorkflowBtn = shadowRoot.getElementById('add-workflow-btn');
    if (addPromptBtn) {
        addPromptBtn.remove();
    }
    if (addWorkflowBtn) {
        addWorkflowBtn.remove();
    }
    
    // Hide add form if visible
    const addPromptForm = shadowRoot.getElementById('add-prompt-form');
    const addWorkflowForm = shadowRoot.getElementById('add-workflow-form');
    if (addPromptForm) {
        addPromptForm.style.display = 'none';
    }
    if (addWorkflowForm) {
        addWorkflowForm.style.display = 'none';
    }
    
    const galleryList = shadowRoot.getElementById('gallery-list');
    if (galleryList) {
        galleryList.style.display = 'block';
    }
});
 
    searchInput.addEventListener('input', async (e) => {
        if (!currentCategory) return;
        const items = await (
            currentCategory === 'prompts' ? loadPrompts() :
            currentCategory === 'notes' ? loadNotes() :
            loadPersonaTemplates()
        );
        renderGalleryList(items, e.target.value);
    });
}

// ========== ADD PROMPT FEATURE ==========
function initializeAddPromptFeature() {
    const galleryHeader = shadowRoot.querySelector('.gallery-header');
    
    // Create add prompt form (hidden by default)
    const addPromptForm = document.createElement('div');
    addPromptForm.id = 'add-prompt-form';
    addPromptForm.style.cssText = `
        display: none;
        padding: 12px;
        background: #2a2a2a;
        border-radius: 6px;
        margin-bottom: 8px;
    `;
    
    addPromptForm.innerHTML = `
        <div style="margin-bottom: 10px;">
            <label style="
                display: block;
                color: rgba(255, 255, 255, 0.7);
                font-size: 11px;
                margin-bottom: 4px;
            ">Title</label>
            <input 
                type="text" 
                id="prompt-title-input"
                placeholder="Enter prompt title..."
                style="
                    width: 100%;
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 4px;
                    padding: 6px 8px;
                    color: white;
                    font-size: 12px;
                    outline: none;
                "
            />
        </div>
        
        <div style="margin-bottom: 10px;">
            <label style="
                display: block;
                color: rgba(255, 255, 255, 0.7);
                font-size: 11px;
                margin-bottom: 4px;
            ">Prompt</label>
            <textarea 
    id="prompt-text-input"
    placeholder="Enter your prompt text..."
    style="
        width: 100%;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 6px 8px;
        color: white;
        font-size: 12px;
        outline: none;
        height: 120px;
        resize: none;
        font-family: inherit;
        line-height: 1.4;
        overflow-y: auto;
    "
></textarea>
        </div>
        
        <div style="display: flex; gap: 8px; justify-content: flex-end;">
            <button id="cancel-add-prompt" style="
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: rgba(255, 255, 255, 0.8);
                padding: 6px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 11px;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                gap: 4px;
            ">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
                Cancel
            </button>
            
            <button id="save-new-prompt" style="
                background: rgba(0, 255, 0, 0.2);
                border: 1px solid rgba(0, 255, 0, 0.4);
                color: #00ff00;
                padding: 6px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 11px;
                font-weight: 600;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                gap: 4px;
            ">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Save
            </button>
        </div>
    `;
    
    // Insert form after gallery header
    const galleryContent = shadowRoot.getElementById('gallery-content');
    const galleryList = shadowRoot.getElementById('gallery-list');
    galleryList.parentNode.insertBefore(addPromptForm, galleryList);
    
    // Add hover effects for buttons
    const cancelBtn = addPromptForm.querySelector('#cancel-add-prompt');
    const saveBtn = addPromptForm.querySelector('#save-new-prompt');
    
    cancelBtn.addEventListener('mouseenter', () => {
        cancelBtn.style.background = 'rgba(255, 255, 255, 0.15)';
    });
    cancelBtn.addEventListener('mouseleave', () => {
        cancelBtn.style.background = 'rgba(255, 255, 255, 0.1)';
    });
    
    saveBtn.addEventListener('mouseenter', () => {
        saveBtn.style.background = 'rgba(0, 255, 0, 0.3)';
    });
    saveBtn.addEventListener('mouseleave', () => {
        saveBtn.style.background = 'rgba(0, 255, 0, 0.2)';
    });
    
    // Add focus styles for inputs
    const titleInput = addPromptForm.querySelector('#prompt-title-input');
    const textInput = addPromptForm.querySelector('#prompt-text-input');
    
    [titleInput, textInput].forEach(input => {
        input.addEventListener('focus', () => {
            input.style.borderColor = 'rgba(255, 255, 0, 0.5)';
            input.style.boxShadow = '0 0 0 2px rgba(255, 255, 0, 0.2)';
        });
        input.addEventListener('blur', () => {
            input.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            input.style.boxShadow = 'none';
        });
    });
    
    
    // Cancel button handler
    // Cancel button handler
cancelBtn.addEventListener('click', () => {
    const galleryHeader = shadowRoot.querySelector('.gallery-header');
    
    // Restore gallery header
    galleryHeader.style.display = 'block';
    
    // Reset form
    titleInput.value = '';
    textInput.value = '';
    addPromptForm.style.display = 'none';
    galleryList.style.display = 'block';
});
    
    // Save button handler
    // Save button handler
saveBtn.addEventListener('click', async () => {
    const title = titleInput.value.trim();
    const text = textInput.value.trim();
    
    // Validation
    if (!title) {
        titleInput.style.borderColor = '#ff6b6b';
        titleInput.focus();
        setTimeout(() => {
            titleInput.style.borderColor = 'rgba(255, 255, 255, 0.2)';
        }, 2000);
        return;
    }
    
    if (!text) {
        textInput.style.borderColor = '#ff6b6b';
        textInput.focus();
        setTimeout(() => {
            textInput.style.borderColor = 'rgba(255, 255, 255, 0.2)';
        }, 2000);
        return;
    }
    
    // Show loading state
    saveBtn.disabled = true;
    saveBtn.innerHTML = `
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="animation: spin 1s linear infinite;">
            <path d="M21 12a9 9 0 11-6.219-8.56"></path>
        </svg>
        Saving...
    `;
    
    // Create new prompt
    const newPrompt = {
        id: Date.now().toString(),
        title: title,
        text: text,
        timestamp: new Date().toISOString()
    };
    
    try {
        // Save to storage
        const data = await chrome.storage.sync.get('savedPrompts');
        const savedPrompts = data.savedPrompts || [];
        savedPrompts.push(newPrompt);
        await chrome.storage.sync.set({ savedPrompts });
        
        console.log('âœ… New prompt saved:', title);
        
        // Show success feedback
        saveBtn.innerHTML = `
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
            Saved!
        `;
        
        // Reset form and refresh list
        setTimeout(async () => {
            // Get references
            const galleryHeader = shadowRoot.querySelector('.gallery-header');
            const galleryList = shadowRoot.getElementById('gallery-list');
            const addPromptForm = shadowRoot.getElementById('add-prompt-form');
            
            // Restore gallery header
            if (galleryHeader) {
                galleryHeader.style.display = 'block';
            }
            
            // Reset inputs
            titleInput.value = '';
            textInput.value = '';
            
            // Hide form, show list
            addPromptForm.style.display = 'none';
            galleryList.style.display = 'block';
            
            // Refresh the prompt list
            const prompts = await loadPrompts();
            renderGalleryList(prompts, shadowRoot.getElementById('gallery-search').value);
            
            // Reset button
            saveBtn.disabled = false;
            saveBtn.innerHTML = `
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Save
            `;
            
            // Show notification
            showNotification('âœ… Prompt saved: ' + title);
        }, 800);
        
    } catch (error) {
        console.error('âŒ Error saving prompt:', error);
        showNotification('âŒ Failed to save prompt', 'error');
        
        // Reset button
        saveBtn.disabled = false;
        saveBtn.innerHTML = `
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
            Save
        `;
    }
});
}

// ========== ADD WORKFLOW FEATURE ==========
function initializeAddWorkflowFeature() {
    const galleryHeader = shadowRoot.querySelector('.gallery-header');
    
    // Create add workflow form (hidden by default)
    const addWorkflowForm = document.createElement('div');
    addWorkflowForm.id = 'add-workflow-form';
    addWorkflowForm.style.cssText = `
        display: none;
        padding: 12px;
        background: #2a2a2a;
        border-radius: 6px;
        margin-bottom: 8px;
    `;
    
    addWorkflowForm.innerHTML = `
        <div style="margin-bottom: 10px;">
            <label style="
                display: block;
                color: rgba(255, 255, 255, 0.7);
                font-size: 11px;
                margin-bottom: 4px;
            ">Workflow Title</label>
            <input 
                type="text" 
                id="workflow-title-input"
                placeholder="e.g., Email Response Workflow"
                style="
                    width: 100%;
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 4px;
                    padding: 6px 8px;
                    color: white;
                    font-size: 12px;
                    outline: none;
                "
            />
        </div>
        
        <div style="margin-bottom: 10px;">
            <label style="
                display: block;
                color: rgba(255, 255, 255, 0.7);
                font-size: 11px;
                margin-bottom: 4px;
            ">Step 1</label>
            <textarea 
                id="workflow-step1-input"
                placeholder="Enter the first step of your workflow..."
                style="
                    width: 100%;
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 4px;
                    padding: 6px 8px;
                    color: white;
                    font-size: 12px;
                    outline: none;
                    height: 80px;
                    resize: none;
                    font-family: inherit;
                    line-height: 1.4;
                    overflow-y: auto;
                "
            ></textarea>
        </div>
        
        <div style="display: flex; gap: 8px; justify-content: flex-end;">
            <button id="cancel-add-workflow" style="
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: rgba(255, 255, 255, 0.8);
                padding: 6px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 11px;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                gap: 4px;
            ">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
                Cancel
            </button>
            
            <button id="create-workflow-btn" style="
                background: rgba(0, 255, 0, 0.2);
                border: 1px solid rgba(0, 255, 0, 0.4);
                color: #00ff00;
                padding: 6px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 11px;
                font-weight: 600;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                gap: 4px;
            ">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Create
            </button>
        </div>
    `;
    
    // Insert form after gallery header
    const galleryContent = shadowRoot.getElementById('gallery-content');
    const galleryList = shadowRoot.getElementById('gallery-list');
    galleryList.parentNode.insertBefore(addWorkflowForm, galleryList);
    
    // Add hover effects for buttons
    const cancelBtn = addWorkflowForm.querySelector('#cancel-add-workflow');
    const createBtn = addWorkflowForm.querySelector('#create-workflow-btn');
    
    cancelBtn.addEventListener('mouseenter', () => {
        cancelBtn.style.background = 'rgba(255, 255, 255, 0.15)';
    });
    cancelBtn.addEventListener('mouseleave', () => {
        cancelBtn.style.background = 'rgba(255, 255, 255, 0.1)';
    });
    
    createBtn.addEventListener('mouseenter', () => {
        createBtn.style.background = 'rgba(0, 255, 0, 0.3)';
    });
    createBtn.addEventListener('mouseleave', () => {
        createBtn.style.background = 'rgba(0, 255, 0, 0.2)';
    });
    
    // Add focus styles for inputs
    const titleInput = addWorkflowForm.querySelector('#workflow-title-input');
    const step1Input = addWorkflowForm.querySelector('#workflow-step1-input');
    
    [titleInput, step1Input].forEach(input => {
        input.addEventListener('focus', () => {
            input.style.borderColor = 'rgba(255, 255, 0, 0.5)';
            input.style.boxShadow = '0 0 0 2px rgba(255, 255, 0, 0.2)';
        });
        input.addEventListener('blur', () => {
            input.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            input.style.boxShadow = 'none';
        });
    });
    
    // Cancel button handler
    cancelBtn.addEventListener('click', () => {
        const galleryHeader = shadowRoot.querySelector('.gallery-header');
        
        // Restore gallery header
        galleryHeader.style.display = 'block';
        
        // Reset form
        titleInput.value = '';
        step1Input.value = '';
        addWorkflowForm.style.display = 'none';
        galleryList.style.display = 'block';
    });
    
    // Create button handler
    createBtn.addEventListener('click', async () => {
        const title = titleInput.value.trim();
        const step1 = step1Input.value.trim();
        
        // Validation
        if (!title) {
            titleInput.style.borderColor = '#ff6b6b';
            titleInput.focus();
            setTimeout(() => {
                titleInput.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            }, 2000);
            return;
        }
        
        if (!step1) {
            step1Input.style.borderColor = '#ff6b6b';
            step1Input.focus();
            setTimeout(() => {
                step1Input.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            }, 2000);
            return;
        }
        
        // Show loading state
        createBtn.disabled = true;
        createBtn.innerHTML = `
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="animation: spin 1s linear infinite;">
                <path d="M21 12a9 9 0 11-6.219-8.56"></path>
            </svg>
            Creating...
        `;
        
        // Create new workflow
        const newWorkflow = {
            id: `workflow-${Date.now()}`,
            name: title.replace(/\s+/g, ''),
            title: title,
            steps: [
                { number: 1, prompt: step1 }
            ],
            timestamp: new Date().toISOString(),
            source: 'user_created'
        };
        
        try {
            // Save to storage
            const data = await chrome.storage.local.get('workflows');
            const workflows = data.workflows || [];
            workflows.push(newWorkflow);
            await chrome.storage.local.set({ workflows });
            
            console.log('âœ… New workflow created:', title);
            
            // Show success feedback
            createBtn.innerHTML = `
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Created!
            `;
            
            // Reset form and refresh list
            setTimeout(async () => {
                // Get references
                const galleryHeader = shadowRoot.querySelector('.gallery-header');
                const galleryList = shadowRoot.getElementById('gallery-list');
                const addWorkflowForm = shadowRoot.getElementById('add-workflow-form');
                
                // Restore gallery header
                if (galleryHeader) {
                    galleryHeader.style.display = 'block';
                }
                
                // Reset inputs
                titleInput.value = '';
                step1Input.value = '';
                
                // Hide form, show list
                addWorkflowForm.style.display = 'none';
                galleryList.style.display = 'block';
                
                // Refresh the workflow list
                const workflows = await loadWorkflows();
                renderGalleryList(workflows, shadowRoot.getElementById('gallery-search').value);
                
                // Reset button
                createBtn.disabled = false;
                createBtn.innerHTML = `
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    Create
                `;
                
                // Show notification
                showNotification('âœ… Workflow created: ' + title);
            }, 800);
            
        } catch (error) {
            console.error('âŒ Error creating workflow:', error);
            showNotification('âŒ Failed to create workflow', 'error');
            
            // Reset button
            createBtn.disabled = false;
            createBtn.innerHTML = `
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Create
            `;
        }
    });
}


function updateGalleryHeaderWithAddButton() {
    // This function will be called when prompts category is selected
    const galleryTitle = shadowRoot.getElementById('gallery-title');
    const titleRow = galleryTitle.parentElement;
    
    // Check if we're in prompts view and add button doesn't exist
    if (currentCategory === 'prompts' && !shadowRoot.getElementById('add-prompt-btn')) {
        const addButton = document.createElement('button');
        addButton.id = 'add-prompt-btn';
        addButton.style.cssText = `
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: rgba(255, 215, 0, 0.8);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
            margin-right: 16px;
        `;
        
        addButton.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="16"></line>
                <line x1="8" y1="12" x2="16" y2="12"></line>
            </svg>
        `;
        
        addButton.addEventListener('mouseenter', () => {
            addButton.style.color = 'rgba(255, 215, 0, 1)';
            addButton.style.transform = 'scale(1.1)';
        });
        
        addButton.addEventListener('mouseleave', () => {
            addButton.style.color = 'rgba(255, 215, 0, 0.8)';
            addButton.style.transform = 'scale(1)';
        });
        
        addButton.addEventListener('click', () => {
            const addPromptForm = shadowRoot.getElementById('add-prompt-form');
            const galleryList = shadowRoot.getElementById('gallery-list');
            const galleryHeader = shadowRoot.querySelector('.gallery-header');
            
            if (addPromptForm) {
                // Hide the gallery header completely
                galleryHeader.style.display = 'none';
                
                // Show the form and hide list
                addPromptForm.style.display = 'block';
                galleryList.style.display = 'none';
                
                // Focus on title input
                setTimeout(() => {
                    shadowRoot.getElementById('prompt-title-input').focus();
                }, 100);
            }
        });
        
        // Create a wrapper for right-side buttons (+ icon and back button)
        const rightButtonsWrapper = document.createElement('div');
        rightButtonsWrapper.style.cssText = `
            display: flex;
            align-items: center;
            gap: 12px;
        `;
        
        // Get the back button
        const backButton = titleRow.querySelector('.back-to-categories');
        
        // Insert + button before back button in the wrapper
        rightButtonsWrapper.appendChild(addButton);
        rightButtonsWrapper.appendChild(backButton);
        
        // Replace the back button with the wrapper
        titleRow.appendChild(rightButtonsWrapper);
    }
}

function updateGalleryHeaderWithAddWorkflowButton() {
    const galleryTitle = shadowRoot.getElementById('gallery-title');
    const titleRow = galleryTitle.parentElement;
    
    // Check if we're in workflows view and add button doesn't exist
    if (currentCategory === 'workflows' && !shadowRoot.getElementById('add-workflow-btn')) {
        const addButton = document.createElement('button');
        addButton.id = 'add-workflow-btn';
        addButton.style.cssText = `
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: rgba(255, 215, 0, 0.8);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
            margin-right: 16px;
        `;
        
        addButton.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="16"></line>
                <line x1="8" y1="12" x2="16" y2="12"></line>
            </svg>
        `;
        
        addButton.addEventListener('mouseenter', () => {
            addButton.style.color = 'rgba(255, 215, 0, 1)';
            addButton.style.transform = 'scale(1.1)';
        });
        
        addButton.addEventListener('mouseleave', () => {
            addButton.style.color = 'rgba(255, 215, 0, 0.8)';
            addButton.style.transform = 'scale(1)';
        });
        
        addButton.addEventListener('click', () => {
            const addWorkflowForm = shadowRoot.getElementById('add-workflow-form');
            const galleryList = shadowRoot.getElementById('gallery-list');
            const galleryHeader = shadowRoot.querySelector('.gallery-header');
            
            if (addWorkflowForm) {
                // Hide the gallery header completely
                galleryHeader.style.display = 'none';
                
                // Show the form and hide list
                addWorkflowForm.style.display = 'block';
                galleryList.style.display = 'none';
                
                // Focus on title input
                setTimeout(() => {
                    shadowRoot.getElementById('workflow-title-input').focus();
                }, 100);
            }
        });
        
        // Create a wrapper for right-side buttons (+ icon and back button)
        const rightButtonsWrapper = document.createElement('div');
        rightButtonsWrapper.style.cssText = `
            display: flex;
            align-items: center;
            gap: 12px;
        `;
        
        // Get the back button
        const backButton = titleRow.querySelector('.back-to-categories');
        
        // Insert + button before back button in the wrapper
        rightButtonsWrapper.appendChild(addButton);
        rightButtonsWrapper.appendChild(backButton);
        
        // Replace the back button with the wrapper
        titleRow.appendChild(rightButtonsWrapper);
    }
}

function renderGalleryList(items, searchTerm = '') {
    const galleryList = shadowRoot.getElementById('gallery-list');
    const filteredItems = searchTerm ? 
        items.filter(item => {
            if (currentCategory === 'chats') {
                return item.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                       item.question.toLowerCase().includes(searchTerm.toLowerCase()) ||
                       item.answer.toLowerCase().includes(searchTerm.toLowerCase());
            }
            if (currentCategory === 'workflows') {
                return item.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                       item.steps.some(step => step.prompt.toLowerCase().includes(searchTerm.toLowerCase()));
            }
            // Search in both title and text for prompts
            return item.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                   item.text.toLowerCase().includes(searchTerm.toLowerCase());
        }) : items;
 
    galleryList.innerHTML = filteredItems.map(item => {
        if (currentCategory === 'workflows') {
            return `
                <div class="gallery-item" data-id="${item.id}">
                    <div class="gallery-item-text">${item.title} (${item.steps.length} steps)</div>
                    <div class="gallery-item-actions">
                        <button class="gallery-copy-btn" data-id="${item.id}" data-type="workflow">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                                <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                            </svg>
                        </button>
                        ${item.source !== 'built_in' ? `
                            <button class="gallery-delete-btn" data-id="${item.id}">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 6h18"></path>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"></path>
                                    <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        ` : ''}
                    </div>
                </div>
            `;
        }
        
        if (currentCategory === 'chats') {
            return `
                <div class="gallery-item" data-id="${item.id}">
                    <div class="gallery-item-text" data-id="${item.id}">${item.title || 'Untitled Chat'}</div>
                    <div class="gallery-item-actions">
                        <button class="gallery-star-btn ${activeChatId === item.id ? 'active' : ''}" data-id="${item.id}">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="${activeChatId === item.id ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">
                                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
                            </svg>
                        </button>
                        <button class="gallery-rename-btn" data-id="${item.id}" title="Rename">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                            </svg>
                        </button>
                        <button class="gallery-copy-btn" data-id="${item.id}">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                                <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                            </svg>
                        </button>
                        <button class="gallery-delete-btn" data-id="${item.id}">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18"></path>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"></path>
                                <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>
                    </div>
                </div>
            `;
        }
 
        // For prompts only
        return `
            <div class="gallery-item" data-id="${item.id}">
                <div class="gallery-item-text" data-id="${item.id}">${item.title || 'Untitled'}</div>
                <div class="gallery-item-actions">
                    ${currentCategory === 'prompts' ? `
                        <button class="gallery-star-btn ${activePromptId === item.id ? 'active' : ''}" data-id="${item.id}">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="${activePromptId === item.id ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">
                                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
                            </svg>
                        </button>
                    ` : ''}
                    <button class="gallery-rename-btn" data-id="${item.id}" title="Rename">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                        </svg>
                    </button>
                    <button class="gallery-copy-btn" data-id="${item.id}">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                            <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                        </svg>
                    </button>
                    <button class="gallery-delete-btn" data-id="${item.id}">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 6h18"></path>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"></path>
                            <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        </svg>
                    </button>
                </div>
            </div>
        `;
    }).join('');

    attachGalleryEventListeners(galleryList);
}

// Replace the entire attachGalleryEventListeners function with this corrected version:

function attachGalleryEventListeners(galleryList) {
    galleryList.querySelectorAll('.gallery-item').forEach(item => {
        // Left-click to view full content
        item.addEventListener('click', async (e) => {
            if (!e.target.closest('button') && !e.target.closest('input')) {
                const itemId = item.dataset.id;
                const items = await (
                    currentCategory === 'prompts' ? loadPrompts() :
                    currentCategory === 'chats' ? loadSavedChats() :
                    loadWorkflows()
                );
                const selectedItem = items.find(i => i.id === itemId);
                if (selectedItem) {
                    hideShimmerLoading();
                    outputText.classList.remove('placeholder', 'shimmer-loading', 'error');
                    outputText.innerHTML = ''; // Clear any previous content

                    if (currentCategory === 'workflows') {
                        // âœ… CRITICAL: Close gallery and show in output container
                        closeAllSections(); // This hides gallery and shows output
                        displayWorkflowSteps(selectedItem);
                    } else if (currentCategory === 'chats') {
                        // Check if it's new Q&A format or old format
                        const isQAFormat = selectedItem.question.includes('Q: ') && selectedItem.question.includes('A: ');
                        
                        if (isQAFormat) {
                            // New format: display as-is
                            outputText.textContent = `${selectedItem.question}\n\n---\n\nPlatform: ${selectedItem.ai}\nDate: ${new Date(selectedItem.date).toLocaleString()}\n\n${selectedItem.hasCode ? 'ðŸ“ Contains code' : ''}${selectedItem.chatLink ? '\nðŸ”— ' + selectedItem.chatLink : ''}`;
                        } else {
                            // Old format: display with labels
                            outputText.textContent = `Question: ${selectedItem.question}\n\nAnswer: ${selectedItem.answer}\n\nPlatform: ${selectedItem.ai}\nDate: ${new Date(selectedItem.date).toLocaleString()}\n\n${selectedItem.hasCode ? 'ðŸ“ Contains code' : ''}${selectedItem.chatLink ? '\nðŸ”— ' + selectedItem.chatLink : ''}`;
                        }
                    } else {
                        // For prompts
                        outputText.textContent = selectedItem.text;
                    }
                    
                    closeAllSections();
                }
            }
        });
    });

    // âœ… ENHANCED: Rename button with Save icon
    galleryList.querySelectorAll('.gallery-rename-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            e.preventDefault();
            
            const itemId = btn.dataset.id;
            const item = btn.closest('.gallery-item');
            const textElement = item.querySelector('.gallery-item-text');
            
            // Load current item
            const items = await (
                currentCategory === 'prompts' ? loadPrompts() :
                currentCategory === 'chats' ? loadSavedChats() :
                loadWorkflows()
            );
            const currentItem = items.find(i => i.id === itemId);
            if (!currentItem) return;
            
            const currentTitle = currentItem.title || 'Untitled';
            
            // Create input field
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentTitle;
            input.style.cssText = `
                width: calc(100% - 30px);
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 215, 0, 0.5);
                border-radius: 3px;
                padding: 4px 6px;
                color: white;
                font-size: 11px;
                font-family: inherit;
                outline: none;
                box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.2);
            `;

            // âœ… NEW: Prevent Claude (and other platforms) from stealing keyboard input
            input.addEventListener('keydown', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            input.addEventListener('keypress', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            input.addEventListener('keyup', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            input.addEventListener('input', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            input.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            input.addEventListener('click', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);
            
            // âœ… NEW: Create Save button
            const saveBtn = document.createElement('button');
            saveBtn.innerHTML = 'âœ“';
            saveBtn.style.cssText = `
                background: rgba(0, 255, 0, 0.2);
                border: 1px solid rgba(0, 255, 0, 0.4);
                color: #00ff00;
                width: 24px;
                height: 24px;
                border-radius: 3px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-left: 4px;
                transition: all 0.2s ease;
            `;
            
            saveBtn.addEventListener('mouseenter', () => {
                saveBtn.style.background = 'rgba(0, 255, 0, 0.3)';
                saveBtn.style.transform = 'scale(1.1)';
            });
            
            saveBtn.addEventListener('mouseleave', () => {
                saveBtn.style.background = 'rgba(0, 255, 0, 0.2)';
                saveBtn.style.transform = 'scale(1)';
            });
            
            // Store original for restoration
            const originalDisplayText = textElement.textContent;
            
            // âœ… NEW: Create wrapper for input + save button
            const inputWrapper = document.createElement('div');
            inputWrapper.style.cssText = `
                display: flex;
                align-items: center;
                width: 100%;
                gap: 4px;
            `;
            
            inputWrapper.appendChild(input);
            inputWrapper.appendChild(saveBtn);
            
            // Replace text with input wrapper
            textElement.style.overflow = 'visible';
            textElement.innerHTML = '';
            textElement.appendChild(inputWrapper);
            
            // Focus input
            setTimeout(() => {
                input.focus();
                input.select();
            }, 50);
            
            // Save function
            const saveRename = async () => {
                const newTitle = input.value.trim();
                
                if (newTitle && newTitle !== currentTitle) {
                    let success = false;
                    
                    if (currentCategory === 'chats') {
                        success = await renameSavedChat(itemId, newTitle);
                    } else if (currentCategory === 'prompts') {
                        success = await renamePrompt(itemId, newTitle);
                    }
                    
                    if (success) {
                        // Reload gallery
                        const updatedItems = await (
                            currentCategory === 'prompts' ? loadPrompts() : 
                            currentCategory === 'chats' ? loadSavedChats() :
                            loadWorkflows()
                        );
                        renderGalleryList(updatedItems, shadowRoot.getElementById('gallery-search').value);
                        
                        // Visual feedback
                        setTimeout(() => {
                            const updatedItem = shadowRoot.querySelector(`[data-id="${itemId}"]`);
                            if (updatedItem) {
                                const updatedTextElement = updatedItem.querySelector('.gallery-item-text');
                                if (updatedTextElement) {
                                    updatedTextElement.style.background = 'rgba(0, 255, 0, 0.2)';
                                    setTimeout(() => {
                                        updatedTextElement.style.background = '';
                                    }, 1000);
                                }
                            }
                        }, 100);
                    } else {
                        textElement.style.overflow = 'hidden';
                        textElement.textContent = originalDisplayText;
                    }
                } else {
                    textElement.style.overflow = 'hidden';
                    textElement.textContent = originalDisplayText;
                }
            };
            
            // Cancel function
            const cancelRename = () => {
                textElement.style.overflow = 'hidden';
                textElement.textContent = originalDisplayText;
            };
            
            // âœ… NEW: Save button click handler
            saveBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                saveRename();
            });
            
            // Event listeners for input - ENHANCED for Claude compatibility
            input.addEventListener('keydown', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
                
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveRename();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelRename();
                }
            }, true);

            input.addEventListener('keypress', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            input.addEventListener('keyup', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            input.addEventListener('input', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            input.addEventListener('blur', () => {
                setTimeout(() => {
                    if (textElement.contains(inputWrapper)) {
                        saveRename();
                    }
                }, 200);
            });

            input.addEventListener('click', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            input.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);
        });
    });

    // Copy button functionality
    galleryList.querySelectorAll('.gallery-copy-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const itemId = btn.dataset.id;
            const items = await (
                currentCategory === 'prompts' ? loadPrompts() :
                currentCategory === 'chats' ? loadSavedChats() :
                loadWorkflows()
            );
            const selectedItem = items.find(i => i.id === itemId);
            if (selectedItem) {
                let textToCopy;

                if (currentCategory === 'workflows') {
                    textToCopy = selectedItem.steps.map(step => `Step ${step.number}: ${step.prompt}`).join('\n\n');
                } else if (currentCategory === 'chats') {
                    textToCopy = `Q: ${selectedItem.question}\n\nA: ${selectedItem.answer}`;
                } else {
                    textToCopy = selectedItem.text;
                }
                    
                await navigator.clipboard.writeText(textToCopy);
                btn.classList.add('copied');
                setTimeout(() => btn.classList.remove('copied'), 1000);
            }
        });
    });

    // Star button functionality (prompts and chats only)
    if (currentCategory === 'prompts' || currentCategory === 'chats') {
        galleryList.querySelectorAll('.gallery-star-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                e.stopPropagation();
                const itemId = btn.dataset.id;
                
                if (currentCategory === 'prompts') {
                    // Prompts star logic
                    if (activePromptId === itemId) {
                        activePromptId = null;
                        isPromptStarActive = false;
                        btn.querySelector('svg').setAttribute('fill', 'none');
                        btn.classList.remove('active');
                    } else {
                        const prevStar = galleryList.querySelector('.gallery-star-btn.active');
                        if (prevStar) {
                            prevStar.querySelector('svg').setAttribute('fill', 'none');
                            prevStar.classList.remove('active');
                        }
                        
                        activePromptId = itemId;
                        isPromptStarActive = true;
                        btn.querySelector('svg').setAttribute('fill', 'currentColor');
                        btn.classList.add('active');
                    }
                } else if (currentCategory === 'chats') {
                    // Chats star logic
                    if (activeChatId === itemId) {
                        activeChatId = null;
                        isChatStarActive = false;
                        btn.querySelector('svg').setAttribute('fill', 'none');
                        btn.classList.remove('active');
                    } else {
                        const prevStar = galleryList.querySelector('.gallery-star-btn.active');
                        if (prevStar) {
                            prevStar.querySelector('svg').setAttribute('fill', 'none');
                            prevStar.classList.remove('active');
                        }
                        
                        activeChatId = itemId;
                        isChatStarActive = true;
                        btn.querySelector('svg').setAttribute('fill', 'currentColor');
                        btn.classList.add('active');
                    }
                }
            });
        });
    }

    // Delete button functionality
    galleryList.querySelectorAll('.gallery-delete-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const itemId = btn.dataset.id;
            
            let deleteFunction;
            let reloadFunction;
            
            if (currentCategory === 'prompts') {
                deleteFunction = deletePrompt;
                reloadFunction = loadPrompts;
            } else if (currentCategory === 'chats') {
                deleteFunction = deleteSavedChat;
                reloadFunction = loadSavedChats;
            } else if (currentCategory === 'workflows') {
                deleteFunction = deleteWorkflow;
                reloadFunction = loadWorkflows;    
            }
            
            if (await deleteFunction(itemId)) {
                const items = await reloadFunction();
                renderGalleryList(items, shadowRoot.getElementById('gallery-search').value);
            }
        });
    });
}

function displayWorkflowSteps(workflow) {
    // Clear everything and start fresh
    outputText.innerHTML = '';
    outputText.className = 'output-text'; // Reset to base class only
    
    // âœ… FIX: Disable scrolling on outputText itself
    outputText.style.overflowY = 'hidden';
    outputText.style.maxHeight = 'none';
    outputText.style.padding = '12px';
    
    // Create workflow container with consistent styling
    const workflowContainer = document.createElement('div');
    workflowContainer.className = 'workflow-container';
    workflowContainer.style.cssText = `
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 280px;
        overflow-y: auto;
    `;
    
    const isBuiltIn = workflow.source === 'built_in';
    
    // Create step bubbles
    workflow.steps.forEach(step => {
        const stepBubble = document.createElement('div');
        stepBubble.className = 'workflow-step-bubble';
        stepBubble.dataset.stepNumber = step.number;
        stepBubble.dataset.workflowId = workflow.id;
        stepBubble.dataset.stepPrompt = step.prompt; // Store full prompt
        
        // Step number badge
        const badge = document.createElement('div');
        badge.style.cssText = `
            background: rgba(255, 215, 0, 0.15);
            color: rgba(255, 215, 0, 0.9);
            font-size: 10px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 30px;
            text-align: center;
            flex-shrink: 0;
        `;
        badge.textContent = `S${step.number}`;
        
        // Step content (truncated by CSS)
        const content = document.createElement('div');
        content.className = 'step-content';
        content.style.cssText = `
        flex: 1;
        color: rgba(255, 255, 255, 0.9);
        font-size: 12px;
        line-height: 1.5;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
    `;
content.textContent = step.prompt;
        
        stepBubble.appendChild(badge);
        stepBubble.appendChild(content);
        
        // Edit button for user-created workflows
        // Edit button for user-created workflows
         // Edit and Delete buttons for user-created workflows
     if (!isBuiltIn) {
    // Make step bubble position relative for absolute positioning of buttons
    stepBubble.style.position = 'relative';
    stepBubble.style.paddingRight = '70px'; // Increased space for both buttons
    
    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-step-btn';
    deleteBtn.dataset.stepNumber = step.number;
    deleteBtn.style.cssText = `
    position: absolute;
    top: 50%;
    right: 10px;
    transform: translateY(-50%);
    background: none;
    border: none;
    padding: 4px;
    cursor: pointer;
    color: rgba(255, 255, 255, 0.3);
    transition: all 0.2s ease;
    z-index: 2;
`;
    deleteBtn.innerHTML = `
        <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
            <path d="M3 6h18"></path>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"></path>
            <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        </svg>
    `;
    
    deleteBtn.addEventListener('mouseenter', () => {
        deleteBtn.style.color = 'rgba(255, 107, 107, 0.95)';
        deleteBtn.style.transform = 'translateY(-50%) scale(1.1)';
    });
    deleteBtn.addEventListener('mouseleave', () => {
        deleteBtn.style.color = 'rgba(255, 255, 255, 0.3)';
        deleteBtn.style.transform = 'translateY(-50%) scale(1)';
    });
    
    // Stop propagation on delete button
    deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
    });
    
    // Edit button (existing code - just update position)
    const editBtn = document.createElement('button');
    editBtn.className = 'edit-step-btn';
    editBtn.dataset.stepNumber = step.number;
    editBtn.style.cssText = `
    position: absolute;
    top: 50%;
    right: 40px;
    transform: translateY(-50%);
    background: none;
    border: none;
    padding: 4px;
    cursor: pointer;
    color: rgba(255, 255, 255, 0.3);
    transition: all 0.2s ease;
    z-index: 2;
`;
    editBtn.innerHTML = `
        <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
        </svg>
    `;
    
    editBtn.addEventListener('mouseenter', () => {
        editBtn.style.color = 'rgba(255, 215, 0, 0.95)';
        editBtn.style.transform = 'translateY(-50%) scale(1.1)';
    });
    editBtn.addEventListener('mouseleave', () => {
        editBtn.style.color = 'rgba(255, 255, 255, 0.3)';
        editBtn.style.transform = 'translateY(-50%) scale(1)';
    });
    
    // Stop propagation on edit button
    editBtn.addEventListener('click', (e) => {
        e.stopPropagation();
    });
    
    stepBubble.appendChild(deleteBtn);
    stepBubble.appendChild(editBtn);
}
        
        // âœ… NEW: Click handler to view full content (like prompts)
        stepBubble.addEventListener('click', (e) => {
            // Don't trigger if clicking edit button
            if (e.target.closest('.edit-step-btn')) return;
            
            // Show full content in output container
            outputText.innerHTML = '';
            outputText.className = 'output-text';
            outputText.style.overflowY = 'auto';
            outputText.style.maxHeight = '150px';
            outputText.style.padding = '12px';
            
            const fullContentView = document.createElement('div');
            fullContentView.style.cssText = `
                color: rgba(255, 255, 255, 0.9);
                font-size: 13px;
                line-height: 1.6;
                white-space: pre-wrap;
            `;
            fullContentView.textContent = `Step ${step.number}: ${step.prompt}`;
            
            outputText.appendChild(fullContentView);
            
            // Close gallery and show output
            closeAllSections();
        });
        
        workflowContainer.appendChild(stepBubble);
    });
    
    // Clone button for built-in workflows
    if (isBuiltIn) {
        const cloneBtn = document.createElement('button');
        cloneBtn.id = 'clone-workflow-btn';
        cloneBtn.dataset.workflowId = workflow.id;
        cloneBtn.style.cssText = `
            width: 100%;
            background: rgba(255, 215, 0, 0.08);
            border: 1px solid rgba(255, 215, 0, 0.25);
            color: rgba(255, 215, 0, 0.95);
            padding: 10px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            margin-top: 8px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        `;
        cloneBtn.innerHTML = `
            <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
            Create Editable Copy
        `;
        
        cloneBtn.addEventListener('mouseenter', () => {
            cloneBtn.style.background = 'rgba(255, 215, 0, 0.12)';
            cloneBtn.style.borderColor = 'rgba(255, 215, 0, 0.35)';
            cloneBtn.style.transform = 'translateY(-1px)';
        });
        cloneBtn.addEventListener('mouseleave', () => {
            cloneBtn.style.background = 'rgba(255, 215, 0, 0.08)';
            cloneBtn.style.borderColor = 'rgba(255, 215, 0, 0.25)';
            cloneBtn.style.transform = 'translateY(0)';
        });
        
        workflowContainer.appendChild(cloneBtn);
    }

    // Add New Step button for user-created workflows
    
    // Add the workflow container to outputText
// Add "Add Step" button INSIDE the workflow container for user-created workflows
    if (!isBuiltIn) {
    const addStepBtn = document.createElement('button');
    addStepBtn.id = 'add-step-btn';
    addStepBtn.dataset.workflowId = workflow.id;
    addStepBtn.style.cssText = `
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.8);
        padding: 6px 10px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 10px !important;
        font-weight: 500;
        margin-top: 6px;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        align-self: flex-start;
        width: auto;
        flex-shrink: 0;
        line-height: 1 !important;
        height: 22px;
    `;
    addStepBtn.innerHTML = `
        <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" style="flex-shrink: 0; display: block;">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
        <span style="display: block; line-height: 1 !important;">Add Step</span>
    `;
    
    addStepBtn.addEventListener('mouseenter', () => {
        addStepBtn.style.background = 'rgba(255, 255, 255, 0.1)';
        addStepBtn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
    });
    addStepBtn.addEventListener('mouseleave', () => {
        addStepBtn.style.background = 'rgba(255, 255, 255, 0.05)';
        addStepBtn.style.borderColor = 'rgba(255, 255, 255, 0.2)';
    });
    
    workflowContainer.appendChild(addStepBtn);
}

// Add the workflow container to outputText
outputText.appendChild(workflowContainer);

// Attach event listeners
if (!isBuiltIn) {
    attachStepEditListeners(workflow);
    attachStepDeleteListeners(workflow);
    attachAddStepButtonListener(workflow);
} else {
    attachCloneButtonListener(workflow);
}
}

function attachStepEditListeners(workflow) {
    shadowRoot.querySelectorAll('.edit-step-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            
            const stepNumber = parseInt(btn.dataset.stepNumber);
            const bubble = btn.closest('.workflow-step-bubble');
            const contentDiv = bubble.querySelector('.step-content');
            const currentPrompt = bubble.dataset.stepPrompt; // Get full prompt from data attribute
            
            // Create input field with full content
            const input = document.createElement('textarea');
            input.value = currentPrompt;
            input.style.cssText = `
                width: 100%;
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 215, 0, 0.5);
                border-radius: 4px;
                padding: 6px 8px;
                color: white;
                font-size: 12px;
                font-family: inherit;
                outline: none;
                resize: vertical;
                min-height: 60px;
                max-height: 150px;
                line-height: 1.4;
                overflow-y: auto;
            `;
            
            // Prevent event propagation
            input.addEventListener('keydown', (e) => e.stopPropagation(), true);
            input.addEventListener('keypress', (e) => e.stopPropagation(), true);
            input.addEventListener('keyup', (e) => e.stopPropagation(), true);
            input.addEventListener('input', (e) => e.stopPropagation(), true);
            
            // Create save button
            const saveBtn = document.createElement('button');
            saveBtn.innerHTML = 'âœ“ Save';
            saveBtn.style.cssText = `
                background: rgba(0, 255, 0, 0.2);
                border: 1px solid rgba(0, 255, 0, 0.4);
                color: #00ff00;
                padding: 4px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 11px;
                font-weight: 600;
                margin-top: 6px;
                transition: all 0.2s ease;
            `;
            
            saveBtn.addEventListener('mouseenter', () => {
                saveBtn.style.background = 'rgba(0, 255, 0, 0.3)';
                saveBtn.style.transform = 'scale(1.05)';
            });
            
            saveBtn.addEventListener('mouseleave', () => {
                saveBtn.style.background = 'rgba(0, 255, 0, 0.2)';
                saveBtn.style.transform = 'scale(1)';
            });
            
            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.innerHTML = 'âœ• Cancel';
            cancelBtn.style.cssText = `
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: rgba(255, 255, 255, 0.7);
                padding: 4px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 11px;
                margin-top: 6px;
                margin-left: 6px;
                transition: all 0.2s ease;
            `;
            
            cancelBtn.addEventListener('mouseenter', () => {
                cancelBtn.style.background = 'rgba(255, 255, 255, 0.1)';
            });
            
            cancelBtn.addEventListener('mouseleave', () => {
                cancelBtn.style.background = 'rgba(255, 255, 255, 0.05)';
            });
            
            const buttonWrapper = document.createElement('div');
            buttonWrapper.appendChild(saveBtn);
            buttonWrapper.appendChild(cancelBtn);
            
            // Store original for restoration
            const originalText = contentDiv.textContent;
            
            // Replace content
            contentDiv.style.overflow = 'visible';
            contentDiv.style.webkitLineClamp = 'unset';
            contentDiv.style.display = 'block';
            contentDiv.innerHTML = '';
            contentDiv.appendChild(input);
            contentDiv.appendChild(buttonWrapper);
            
            // Hide edit button
            btn.style.display = 'none';
            
            input.focus();
            
            // Save function
            const saveEdit = async () => {
                const newPrompt = input.value.trim();
                
                if (newPrompt && newPrompt !== currentPrompt) {
                    // Update workflow in storage
                    const data = await chrome.storage.local.get('workflows');
                    const workflows = data.workflows || [];
                    const workflowIndex = workflows.findIndex(w => w.id === workflow.id);
                    
                    if (workflowIndex !== -1) {
                        const stepIndex = workflows[workflowIndex].steps.findIndex(s => s.number === stepNumber);
                        if (stepIndex !== -1) {
                            workflows[workflowIndex].steps[stepIndex].prompt = newPrompt;
                            workflows[workflowIndex].timestamp = new Date().toISOString();
                            
                            await chrome.storage.local.set({ workflows });
                            
                            // Update display and data attribute
                            // Update display and data attribute
                            bubble.dataset.stepPrompt = newPrompt;

                            // Clear content first
                            contentDiv.innerHTML = '';
                            contentDiv.textContent = '';

                            // Reset all inline styles
                            contentDiv.style.cssText = '';

                           // Apply truncation styles
                           contentDiv.className = 'step-content';
                           contentDiv.style.cssText = `
                           flex: 1;
                           color: rgba(255, 255, 255, 0.9);
                           font-size: 12px;
                           line-height: 1.5;
                           overflow: hidden;
                           text-overflow: ellipsis;
                           display: -webkit-box;
                           -webkit-line-clamp: 2;
                           -webkit-box-orient: vertical;
                        `;

                            // Set the new text
                            contentDiv.textContent = newPrompt;

                            // Show edit button again
                            btn.style.display = 'block';
                            
                            // Show success feedback
                            bubble.style.background = 'rgba(0, 255, 0, 0.1)';
                            bubble.style.borderColor = 'rgba(0, 255, 0, 0.3)';
                            setTimeout(() => {
                                bubble.style.background = 'rgba(255, 255, 255, 0.03)';
                                bubble.style.borderColor = 'rgba(255, 255, 255, 0.12)';
                            }, 1000);
                            
                            console.log('âœ… Step updated successfully');
                        }
                    }
                } else {
                    contentDiv.style.overflow = 'hidden';
                    contentDiv.style.display = '-webkit-box';
                    contentDiv.textContent = originalText;
                    btn.style.display = 'block';
                }
            };
            
            const cancelEdit = () => {
    contentDiv.style.cssText = `
        flex: 1;
        color: rgba(255, 255, 255, 0.9);
        font-size: 12px;
        line-height: 1.5;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
    `;
    contentDiv.textContent = originalText;
    btn.style.display = 'block';
};
            
            saveBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                saveEdit();
            });
            
            cancelBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                cancelEdit();
            });
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelEdit();
                }
            });
        });
    });
}

function attachStepDeleteListeners(workflow) {
    shadowRoot.querySelectorAll('.delete-step-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            
            const stepNumber = parseInt(btn.dataset.stepNumber);
            
            // Confirm deletion
            const bubble = btn.closest('.workflow-step-bubble');
            const stepContent = bubble.dataset.stepPrompt;
            
            // Visual confirmation (optional - you can add a confirm dialog instead)
            bubble.style.background = 'rgba(255, 107, 107, 0.2)';
            bubble.style.borderColor = 'rgba(255, 107, 107, 0.4)';
            
            // Short delay for visual feedback
            await new Promise(resolve => setTimeout(resolve, 200));
            
            try {
                // Load workflow from storage
                const data = await chrome.storage.local.get('workflows');
                const workflows = data.workflows || [];
                const workflowIndex = workflows.findIndex(w => w.id === workflow.id);
                
                if (workflowIndex !== -1) {
                    // Remove the step
                    const stepIndex = workflows[workflowIndex].steps.findIndex(s => s.number === stepNumber);
                    
                    if (stepIndex !== -1) {
                        workflows[workflowIndex].steps.splice(stepIndex, 1);
                        
                        // Re-number remaining steps
                        workflows[workflowIndex].steps.forEach((step, idx) => {
                            step.number = idx + 1;
                        });
                        
                        workflows[workflowIndex].timestamp = new Date().toISOString();
                        
                        // Save to storage
                        await chrome.storage.local.set({ workflows });
                        
                        console.log('âœ… Step deleted successfully');
                        
                        // Reload workflow display
                        displayWorkflowSteps(workflows[workflowIndex]);
                        
                        // Show success notification
                        showNotification('Step deleted', 'success');
                    }
                }
            } catch (error) {
                console.error('âŒ Error deleting step:', error);
                showNotification('Failed to delete step', 'error');
                
                // Reset visual state on error
                bubble.style.background = 'rgba(255, 255, 255, 0.03)';
                bubble.style.borderColor = 'rgba(255, 255, 255, 0.12)';
            }
        });
    });
}

function attachCloneButtonListener(workflow) {
    const cloneBtn = shadowRoot.getElementById('clone-workflow-btn');
    if (!cloneBtn) return;
    
    cloneBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        
        // Show loading state
        const originalHTML = cloneBtn.innerHTML;
        cloneBtn.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="animation: spin 1s linear infinite;">
                <path d="M21 12a9 9 0 11-6.219-8.56"></path>
            </svg>
            Creating copy...
        `;
        cloneBtn.disabled = true;
        
        // Create cloned workflow
        const clonedWorkflow = {
            id: `workflow-${Date.now()}`,
            name: workflow.name + 'Copy',
            title: workflow.title + ' (My Copy)',
            steps: workflow.steps.map(step => ({ ...step })), // Deep copy steps
            timestamp: new Date().toISOString(),
            source: 'user_created'
        };
        
        try {
            // Save to storage
            const data = await chrome.storage.local.get('workflows');
            const workflows = data.workflows || [];
            workflows.push(clonedWorkflow);
            await chrome.storage.local.set({ workflows });
            
            console.log('âœ… Workflow cloned:', clonedWorkflow.title);
            
            // Show success message
            cloneBtn.innerHTML = `
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Created! Opening...
            `;
            cloneBtn.style.background = 'rgba(0, 255, 0, 0.2)';
            cloneBtn.style.borderColor = 'rgba(0, 255, 0, 0.4)';
            cloneBtn.style.color = '#00ff00';
            
            // Wait a moment, then display the cloned workflow
            setTimeout(() => {
                displayWorkflowSteps(clonedWorkflow);
                
                // Refresh gallery if it's open
                if (shadowRoot.getElementById('gallery-view').style.display === 'block') {
                    loadWorkflows().then(workflows => {
                        const galleryList = shadowRoot.getElementById('gallery-list');
                        if (galleryList && currentCategory === 'workflows') {
                            renderGalleryList(workflows, shadowRoot.getElementById('gallery-search').value);
                        }
                    });
                }
            }, 1000);
            
        } catch (error) {
            console.error('âŒ Error cloning workflow:', error);
            cloneBtn.innerHTML = originalHTML;
            cloneBtn.disabled = false;
            showNotification('Failed to create copy', 'error');
        }
    });
}

function attachAddStepButtonListener(workflow) {
    const addStepBtn = shadowRoot.getElementById('add-step-btn');
    if (!addStepBtn) return;
    
    addStepBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        
        // Show loading state
        const originalHTML = addStepBtn.innerHTML;
        addStepBtn.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="animation: spin 1s linear infinite;">
                <path d="M21 12a9 9 0 11-6.219-8.56"></path>
            </svg>
            Adding step...
        `;
        addStepBtn.disabled = true;
        
        try {
            // Load workflow from storage
            const data = await chrome.storage.local.get('workflows');
            const workflows = data.workflows || [];
            const workflowIndex = workflows.findIndex(w => w.id === workflow.id);
            
            if (workflowIndex !== -1) {
                // Create new step
                const newStepNumber = workflows[workflowIndex].steps.length + 1;
                const newStep = {
                    number: newStepNumber,
                    prompt: `Step ${newStepNumber} prompt`
                };
                
                // Add to workflow
                workflows[workflowIndex].steps.push(newStep);
                workflows[workflowIndex].timestamp = new Date().toISOString();
                
                // Save to storage
                await chrome.storage.local.set({ workflows });
                
                console.log('âœ… New step added successfully');
                
                // Show success message
                addStepBtn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    Step added!
                `;
                addStepBtn.style.background = 'rgba(0, 255, 0, 0.2)';
                addStepBtn.style.borderColor = 'rgba(0, 255, 0, 0.4)';
                
                // Reload workflow display after a moment
                setTimeout(() => {
                    displayWorkflowSteps(workflows[workflowIndex]);
                }, 800);
                
            } else {
                throw new Error('Workflow not found');
            }
            
        } catch (error) {
            console.error('âŒ Error adding step:', error);
            addStepBtn.innerHTML = originalHTML;
            addStepBtn.disabled = false;
            showNotification('Failed to add step', 'error');
        }
    });
}

function positionContainer(buttonRect) {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    solthronContainer.style.width = '320px';
    solthronContainer.style.maxHeight = '400px';
    
    let leftPosition = buttonRect.right - 320;
    let topPosition = buttonRect.top - 10;
    
    if (leftPosition < 10) {
        leftPosition = 10;
    } else if (leftPosition + 320 > windowWidth - 10) {
        leftPosition = windowWidth - 330;
    }
    
    const containerHeight = 400;
    if (topPosition + containerHeight > windowHeight - 10) {
        topPosition = windowHeight - containerHeight - 10;
    }
    
    if (topPosition < 10) {
        topPosition = 10;
    }
    
    solthronContainer.style.position = 'fixed';
    solthronContainer.style.left = `${leftPosition}px`;
    solthronContainer.style.top = `${topPosition}px`;
    solthronContainer.style.zIndex = '10001';
    
    solthronContainer.style.transform = 'none';
    solthronContainer.style.opacity = '0';
    
    solthronContainer.style.transition = 'opacity 0.2s ease';
    
    requestAnimationFrame(() => {
        solthronContainer.style.opacity = '1';
    });
}

function initializeUIHandlers() {
    let isDragging = false;
    let currentX;
    let currentY;
    let lastResult = localStorage.getItem('solthron-last-result');

    const copyBtn = shadowRoot.querySelector('#copy-btn');
    const closeBtn = shadowRoot.querySelector('#close-btn');
    const modeSelect = shadowRoot.querySelector('.mode-select');

    selectedMode = localStorage.getItem('solthron-mode') || 'save_prompt';    modeSelect.value = selectedMode;
    solthronContainer.style.display = 'none';
    solthronContainer.style.pointerEvents = 'none';

    if (lastResult) {
        outputText.classList.remove('placeholder');
        outputText.textContent = lastResult;
    }

    button.addEventListener('mousedown', (e) => {
        isDragging = true;
        currentX = e.clientX - button.offsetLeft;
        currentY = e.clientY - button.offsetTop;
    });

    document.addEventListener('mousemove', (e) => {
        if (isDragging) {
            e.preventDefault();
            button.style.left = `${e.clientX - currentX}px`;
            button.style.top = `${e.clientY - currentY}px`;
        }
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
    });

    button.addEventListener('click', async (e) => {
    e.stopPropagation();
    
    if (!isDragging) {
        triggerDoubleClickAnimation();
        
        const selectedText = window.getSelection().toString().trim();

        if (!selectedText || selectedMode === 'image' || selectedMode === 'smart_followups' || selectedMode === 'smart_actions') {
            if (lastResult && selectedMode !== 'smart_followups' && selectedMode !== 'smart_actions' && selectedMode !== 'smart_enhancements') {
                outputText.classList.remove('placeholder');
                outputText.textContent = lastResult;
            } else {
                outputText.classList.add('placeholder');

                const placeholderMessages = {
                    image_prompt: 'Right-click an image to generate a prompt...',
                    save_prompt: 'Highlight text and click to save as prompt...',
                    smart_followups: 'Right-click on an AI chat page to generate follow-up questions...',
                    default: 'Highlight text to begin...'
                };    
                outputText.textContent = placeholderMessages[selectedMode] || placeholderMessages.default;
            }
            const buttonRect = button.getBoundingClientRect();
            solthronContainer.style.display = 'block';
            solthronContainer.style.pointerEvents = 'auto';
            positionContainer(buttonRect);
            return;
        }
        
        await processSelectedText(selectedText);
    }
});

    modeSelect.addEventListener('change', (e) => {
    selectedMode = e.target.value;
    localStorage.setItem('solthron-mode', selectedMode);
    
    // Track if a right-click feature was selected
    const isRightClickMode = selectedMode === 'image_prompt' || selectedMode === 'smart_followups';
    
    if (isRightClickMode) {
        rightClickFeaturesEnabled = true;
        lastSelectedRightClickMode = selectedMode;
    } else {
        // Non-right-click modes disable right-click features
        rightClickFeaturesEnabled = false;
        lastSelectedRightClickMode = null;
    }
    
    outputText.classList.add('placeholder');

    const placeholderMessages = {
        image_prompt: 'Right-click an image to generate a prompt...',
        save_prompt: 'Highlight text and double-click to save as prompt...',
        smart_followups: 'Right-click on an AI chat page to generate follow-up questions...',
        default: 'Highlight text to begin...'
    };
    
        outputText.textContent = placeholderMessages[selectedMode] || placeholderMessages.default;
        lastResult = null;
        localStorage.removeItem('solthron-last-result');
    });

    copyBtn.addEventListener('click', async () => {
        if (outputText.classList.contains('placeholder')) return;
        
        try {
            if (selectedMode === 'smart_followups' && outputText.querySelector('.smart-followups-container')) {
                const questions = Array.from(outputText.querySelectorAll('.followup-question'))
                    .map(q => q.textContent)
                    .join('\n\n');
                await navigator.clipboard.writeText(questions);
            } else if (selectedMode === 'smart_actions' && outputText.querySelector('.smart-actions-container')) {
                const prompts = Array.from(outputText.querySelectorAll('.action-prompt'))
                    .map((prompt, index) => `${index + 1}. ${prompt.textContent}`)
                    .join('\n\n');
                await navigator.clipboard.writeText(prompts);
            } else {
                await navigator.clipboard.writeText(outputText.textContent);
            }
            
            const checkIcon = copyBtn.querySelector('svg');
            checkIcon.style.stroke = '#00ff00';
            copyBtn.classList.add('copied');
            
            setTimeout(() => {
                solthronContainer.style.display = 'none';
                solthronContainer.style.pointerEvents = 'none';
                checkIcon.style.stroke = 'currentColor';
                copyBtn.classList.remove('copied');
            }, 1000);
        } catch (err) {
            console.error('Failed to copy:', err);
        }
    });

    closeBtn.addEventListener('click', () => {
        solthronContainer.style.display = 'none';
        solthronContainer.style.pointerEvents = 'none';
        // Reset view state when closing
        closeAllSections();
    });

    // âœ… FIXED: Handle clicks inside shadow DOM properly
    solthronContainer.addEventListener('click', (e) => {
        // Stop clicks inside container from bubbling to document
        e.stopPropagation();
    });

    // Document click handler for closing container (outside clicks)
    document.addEventListener('click', (e) => {
        // In Shadow DOM, we need to check if click is outside the shadow host
        const shadowHost = shadowRoot.host;
        if (!shadowHost.contains(e.target) && 
            solthronContainer.style.display === 'block') {
            solthronContainer.style.display = 'none';
            solthronContainer.style.pointerEvents = 'none';
        }
    });

    // ========== MAGIC PILL AUTO-INITIALIZATION ==========
    // Load saved preference and initialize magic pill automatically
    autoModeEnabled = true; // Always enabled

    
    // Initialize magic pill immediately for supported platforms
    const currentPlatform = detectAIPlatform();
    if (currentPlatform !== 'unknown') {

        setTimeout(() => {
            initializeMagicPill();
        }, 1000);
    }
}

// âœ… FIXED: Add exclusive view management
function closeAllSections() {
    const profileView = shadowRoot.getElementById('profile-view');
    const galleryView = shadowRoot.getElementById('gallery-view');
    const outputContainer = shadowRoot.querySelector('.output-container');
    const profileBtn = shadowRoot.getElementById('profile-btn');
    const galleryBtn = shadowRoot.getElementById('gallery-btn');
    
    // Close all views
    profileView.style.display = 'none';
    galleryView.style.display = 'none';
    outputContainer.style.display = 'block';
    
    // Reset all icon colors
    profileBtn.querySelector('svg').style.stroke = 'currentColor';
    galleryBtn.querySelector('svg').style.stroke = 'currentColor';
}

function initializeProfileHandlers() {
    const profileBtn = shadowRoot.getElementById('profile-btn');
    const profileView = shadowRoot.getElementById('profile-view');
    const closeProfile = shadowRoot.querySelector('.close-profile');
    const loginContainer = shadowRoot.getElementById('login-container');
    const profileDetails = shadowRoot.getElementById('profile-details');
    const loginButton = shadowRoot.getElementById('login-button');
    const loginError = shadowRoot.getElementById('login-error');
    
    checkAuthState();
    
    async function checkAuthState() {
        const isLoggedIn = await BackendAuth.isLoggedIn();
        updateProfileView(isLoggedIn);
    }
    
    profileBtn.addEventListener('click', () => {
        const isVisible = profileView.style.display !== 'none';
        
        if (isVisible) {
            // Close profile and show output
            closeAllSections();
        } else {
            // Close all other sections and show profile
            closeAllSections();
            profileView.style.display = 'block';
            shadowRoot.querySelector('.output-container').style.display = 'none';
            profileBtn.querySelector('svg').style.stroke = '#00ff00';
            
            checkAuthState();
        }
    });
    
    closeProfile.addEventListener('click', () => {
        closeAllSections();
    });
    
    loginButton.addEventListener('click', async (e) => {
        e.preventDefault();
        
        try {
            const extensionId = chrome.runtime.id;
            const loginUrl = `https://solthron.com/login?extension=true&extensionId=${extensionId}`;
            window.open(loginUrl, '_blank');
            
        } catch (error) {
            console.error('Login redirect error:', error);
            showLoginError('Failed to open login page');
        }
    });

    // Add signup button handler
    const signupButton = shadowRoot.getElementById('signup-button');
    if (signupButton) {
        signupButton.addEventListener('click', async (e) => {
            e.preventDefault();
            
            try {
                const extensionId = chrome.runtime.id;
                const signupUrl = `https://solthron.com/signup?extension=true&extensionId=${extensionId}`;
                window.open(signupUrl, '_blank');
                
            } catch (error) {
                console.error('Signup redirect error:', error);
                showLoginError('Failed to open signup page');
            }
        });
    }

    // Add view switching handlers
    const showSignupLink = shadowRoot.getElementById('show-signup');
    const showLoginLink = shadowRoot.getElementById('show-login');
    const loginView = shadowRoot.getElementById('login-view');
    const signupView = shadowRoot.getElementById('signup-view');

    if (showSignupLink) {
        showSignupLink.addEventListener('click', (e) => {
            e.preventDefault();
            loginView.style.display = 'none';
            signupView.style.display = 'block';
            clearLoginError();
        });
    }

    if (showLoginLink) {
        showLoginLink.addEventListener('click', (e) => {
            e.preventDefault();
            signupView.style.display = 'none';
            loginView.style.display = 'block';
            clearLoginError();
        });
    }

    // Helper function to create auth iframe
function createAuthIframe(type = 'signup') {
    return new Promise((resolve, reject) => {
        // Create iframe
        const iframe = document.createElement('iframe');
        iframe.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 350px;
            border: none;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            z-index: 999999;
            border: 1px solid rgba(255,255,255,0.1);
        `;
        
        // Create backdrop
        const backdrop = document.createElement('div');
        backdrop.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999998;
            backdrop-filter: blur(4px);
        `;
        
        const authUrl = `https://solthron.com/quick-auth?type=${type}&extension=true`;
        iframe.src = authUrl;
        
        document.body.appendChild(backdrop);
        document.body.appendChild(iframe);
        
        // Listen for auth success
        // Listen for auth success
const messageHandler = (event) => {

    
    if ((event.origin === 'https://solthron.com' || event.origin === 'https://www.solthron.com') && 
        event.data.type === 'SOLTHRON_AUTH_SUCCESS') {
        

        
        // Clean up
        try {
            if (document.body.contains(iframe)) {
                document.body.removeChild(iframe);
            }
            if (document.body.contains(backdrop)) {
                document.body.removeChild(backdrop);
            }
        } catch (e) {

        }
        
        window.removeEventListener('message', messageHandler);
        
        resolve(event.data.token);
    }
};
        
        // Close on backdrop click
        backdrop.addEventListener('click', () => {
            document.body.removeChild(iframe);
            document.body.removeChild(backdrop);
            window.removeEventListener('message', messageHandler);
            reject(new Error('User cancelled'));
        });
        
        window.addEventListener('message', messageHandler);
        
        // Auto-close after 60 seconds
        setTimeout(() => {
            if (document.body.contains(iframe)) {
                document.body.removeChild(iframe);
                document.body.removeChild(backdrop);
                window.removeEventListener('message', messageHandler);
                reject(new Error('Auth timeout'));
            }
        }, 120000);
    });
}

// Google Signup Button Handler
shadowRoot.getElementById('google-signup-btn').addEventListener('click', async (e) => {
    e.preventDefault();
    
    try {
        // Show loading
        const originalHTML = e.target.innerHTML;
        e.target.innerHTML = `
            <div style="width: 18px; height: 18px; border: 2px solid #f3f3f3; border-top: 2px solid #4285f4; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 10px;"></div>
            Signing up...
        `;
        e.target.disabled = true;
        
        // Create auth iframe
        const token = await createAuthIframe('signup');
        
        // Store token
        await BackendAuth.setAuthToken(token);
        pageCredits = null;
        
        // Update UI
        updateProfileView(true);
        

        
    } catch (error) {
        console.error('Google signup error:', error);
        if (error.message !== 'User cancelled') {
            showLoginError('Signup failed: ' + error.message);
        }
        
        // Reset button
        e.target.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" style="margin-right: 10px;">
                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
            </svg>
            Sign up with Google
        `;
        e.target.disabled = false;
    }
});

// Google Login Button Handler
shadowRoot.getElementById('google-login-btn').addEventListener('click', async (e) => {
    e.preventDefault();
    
    try {
        // Show loading
        const originalHTML = e.target.innerHTML;
        e.target.innerHTML = `
            <div style="width: 18px; height: 18px; border: 2px solid #f3f3f3; border-top: 2px solid #4285f4; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 10px;"></div>
            Logging in...
        `;
        e.target.disabled = true;
        
        // Create auth iframe
        const token = await createAuthIframe('login');
        
        // Store token
        await BackendAuth.setAuthToken(token);
        pageCredits = null;
        
        // Update UI
        updateProfileView(true);
        

        
    } catch (error) {
        console.error('Google login error:', error);
        if (error.message !== 'User cancelled') {
            showLoginError('Login failed: ' + error.message);
        }
        
        // Reset button
        e.target.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" style="margin-right: 10px;">
                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
            </svg>
            Login with Google
        `;
        e.target.disabled = false;
    }
});
    
    async function updateProfileView(isLoggedIn = null) {
        if (isLoggedIn === null) {
            isLoggedIn = await BackendAuth.isLoggedIn();
        }
        
        if (isLoggedIn) {
            loginContainer.style.display = 'none';
            profileDetails.style.display = 'block';
            
            try {
                const credits = await BackendAuth.getUserCredits();
                
                profileDetails.innerHTML = `
                    <div class="profile-info">
                        <div class="profile-field">
                            <div class="field-label">Status</div>
                            <div class="field-value">Logged In</div>
                        </div>
                        <div class="profile-field">
                            <div class="field-label">Account</div>
                            <div class="field-value">Active</div>
                        </div>
                        <div class="profile-field credits">
                            <div class="field-label">Available Credits</div>
                            <div class="field-value-with-button">
                                <div class="field-value">${credits}</div>
                                <button class="buy-credits-btn" id="buy-credits-btn">Buy Credits</button>
                            </div>
                        </div>
                    </div>
                    <button class="logout-button" id="logout-btn">Logout</button>
                `;
                
                shadowRoot.getElementById('buy-credits-btn').addEventListener('click', () => {
                    window.open('https://www.solthron.com/subscription', '_blank');
                });

                shadowRoot.getElementById('logout-btn').addEventListener('click', async () => {
                    try {
                        await BackendAuth.logout();
                        updateProfileView(false);
                    } catch (error) {
                        console.error('Logout error:', error);
                    }
                });
                
            } catch (error) {
                console.error('Error loading profile:', error);
                profileDetails.innerHTML = `
    <div class="profile-info">
        <div class="profile-field">
            <div class="field-label">Status</div>
            <div class="field-value">Logged In</div>
        </div>
        <div class="profile-field">
            <div class="field-label">Account</div>
            <div class="field-value">Error loading profile data</div>
        </div>
        <div class="profile-field credits">
            <div class="field-label">Available Credits</div>
            <div class="field-value-with-button">
                <div class="field-value">--</div>
                <button class="buy-credits-btn" id="buy-credits-btn-error">Buy Credits</button>
            </div>
        </div>
    </div>
    <button class="logout-button" id="logout-btn">Logout</button>
`;
                shadowRoot.getElementById('buy-credits-btn-error').addEventListener('click', () => {
                window.open('https://www.solthron.com/subscription', '_blank');
                });
                shadowRoot.getElementById('logout-btn').addEventListener('click', async () => {
                    try {
                        await BackendAuth.logout();
                        updateProfileView(false);
                    } catch (error) {
                        console.error('Logout error:', error);
                    }
                });
            }
        } else {
    loginContainer.style.display = 'block';
    profileDetails.style.display = 'none';
    clearLoginError();
    
    // Reset to login view
    const loginView = shadowRoot.getElementById('login-view');
    const signupView = shadowRoot.getElementById('signup-view');
    if (loginView && signupView) {
        loginView.style.display = 'block';
        signupView.style.display = 'none';
    }
    
    // Reset Google button states
    setTimeout(() => {
        const googleSignupBtn = shadowRoot.getElementById('google-signup-btn');
        const googleLoginBtn = shadowRoot.getElementById('google-login-btn');
        
        if (googleSignupBtn) {
            googleSignupBtn.disabled = false;
            googleSignupBtn.innerHTML = `
                <svg width="18" height="18" viewBox="0 0 24 24" style="margin-right: 10px;">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Sign up with Google
            `;
        }
        
        if (googleLoginBtn) {
            googleLoginBtn.disabled = false;
            googleLoginBtn.innerHTML = `
                <svg width="18" height="18" viewBox="0 0 24 24" style="margin-right: 10px;">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Login with Google
            `;
        }
    }, 100);
}
    }
    
    function showLoginError(message) {
        const loginError = shadowRoot.getElementById('login-error');
        if (loginError) {
            loginError.textContent = message;
            loginError.style.display = 'block';
        }
    }
    
    function clearLoginError() {
        const loginError = shadowRoot.getElementById('login-error');
        if (loginError) {
            loginError.textContent = '';
            loginError.style.display = 'none';
        }
    }
}

// Context menu handlers (right-click functionality)
document.addEventListener('contextmenu', async (e) => {
    // Check if right-click features are enabled
    if (!rightClickFeaturesEnabled || !isButtonVisible) {
        return; // Let normal right-click behavior happen
    }
    
    const target = e.target;
    
    if (isImage(target) && selectedMode === 'image_prompt') {
        e.preventDefault();
        
        showShimmerLoading('Processing image...');
        solthronContainer.style.display = 'block';
        solthronContainer.style.pointerEvents = 'auto';
        const buttonRect = button.getBoundingClientRect();
        positionContainer(buttonRect);
        await processImage(target);
        return;
    }
    
    if (selectedMode === 'smart_followups') {
        const platform = detectAIPlatform();
        
        if (platform === 'unknown') {
            return; // Let normal right-click behavior happen
        }
        
        e.preventDefault();
        
        const conversation = extractConversation();

        if (!conversation || conversation === 'Unable to extract conversation from this page.') {
            showError('Unable to extract conversation. Please ensure there is a conversation visible on the page.');
            solthronContainer.style.display = 'block';
            solthronContainer.style.pointerEvents = 'auto';
            const buttonRect = button.getBoundingClientRect();
            positionContainer(buttonRect);
            return;
        }
        
        showShimmerLoading('Generating followups...');
        solthronContainer.style.display = 'block';
        solthronContainer.style.pointerEvents = 'auto';
        const buttonRect = button.getBoundingClientRect();
        positionContainer(buttonRect);
        
        const creditCheck = await checkCredits('smart_followups');
        if (!creditCheck.success) {
            showError(creditCheck.message || "Please check your account status.");
            return;
        }
        
        try {
            const response = await new Promise((resolve, reject) => {
                chrome.runtime.sendMessage({
                    type: 'smart_followups',
                    data: {
                        conversation: conversation,
                        platform: platform
                    }
                }, response => {
                    if (chrome.runtime.lastError) {
                        reject(chrome.runtime.lastError);
                    } else {
                        resolve(response);
                    }
                });
            });
            
            if (response && response.success && response.data) {
                if (response.data.questions && Array.isArray(response.data.questions)) {
                    displaySmartFollowups(response.data);
                } else if (response.data.success && response.data.questions) {
                    displaySmartFollowups(response.data);
                } else {
                    showError('Invalid response format from smart followups service');
                }
            } else {
                const errorMsg = response?.error || response?.data?.error || 'Unknown error occurred';
                showError('Failed to generate follow-up questions: ' + errorMsg);
            }
        } catch (error) {
            console.error('Smart followups error:', error);
            showError('Error analyzing conversation: ' + error.message);
        }
    }
});

async function processImage(img) {
    if (!img.src) return;

    const creditCheck = await checkCredits(selectedMode);
    if (!creditCheck.success) {
        showError(creditCheck.message || "Please check your account status.");
        return;
    }

    try {
        const response = await fetch(img.src);
        const blob = await response.blob();
        const reader = new FileReader();
        const base64Image = await new Promise((resolve) => {
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        });

        const apiResponse = await new Promise((resolve, reject) => {
            chrome.runtime.sendMessage({
                type: 'process_image',
                data: {
                    imageUrl: base64Image,
                    mode: selectedMode
                }
            }, response => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve(response);
                }
            });
        });

        if (apiResponse && apiResponse.success) {
            updateOutput(apiResponse.data.prompt);
        } else {
            throw new Error('Failed to process image');
        }
    } catch (error) {
        showError('Error processing image');
    }
}

// Chrome runtime message handler
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.action === "toggleExtension") {
        isButtonVisible = !isButtonVisible;
        
        button.style.display = isButtonVisible ? 'block' : 'none';
        
        if (!isButtonVisible) {
            // Disable right-click features when extension is hidden
            rightClickFeaturesEnabled = false;
            lastSelectedRightClickMode = null;
            
            
            if (solthronContainer.style.display === 'block') {
                solthronContainer.style.display = 'none';
                solthronContainer.style.pointerEvents = 'none';
            }
        } else {
            // Re-enable right-click features if a right-click mode was previously selected
            const isRightClickMode = selectedMode === 'image_prompt' || selectedMode === 'smart_followups';
            if (isRightClickMode) {
                rightClickFeaturesEnabled = true;
                lastSelectedRightClickMode = selectedMode;

            }
        }
        
        sendResponse({success: true});
        return true;
    }
    
    if (request.action === "setAuthToken" && request.token) {
        BackendAuth.setAuthToken(request.token).then(() => {
            pageCredits = null;
            sendResponse({success: true});
        }).catch((error) => {
            console.error('Error setting auth token:', error);
            sendResponse({success: false});
        });
        return true;
    }
    
    return false;
});

// Auth token receiver for website login
window.addEventListener('message', async (event) => {
    if (event.origin !== 'https://solthron.com' && 
        event.origin !== 'https://www.solthron.com') {
        return;
    }
    
    if (event.data.type === 'SOLTHRON_AUTH_SUCCESS' && event.data.token) {


        
        try {
            const success = await BackendAuth.setAuthToken(event.data.token);
            if (success) {

                pageCredits = null;
                
                const profileView = shadowRoot.getElementById('profile-view');
                if (profileView && profileView.style.display !== 'none') {

                }
                
            } else {
                console.error('âŒ Failed to store auth token');
            }
        } catch (error) {
            console.error('ðŸ’¥ Auth token storage error:', error);
        }
    }
});

// Export for external access
window.solthronAuth = BackendAuth;

// Debug functions
window.solthronDebug = {
    checkAuth: async function() {
        const hasToken = await BackendAuth.getAuthToken();
        const isLoggedIn = await BackendAuth.isLoggedIn();
        const credits = await BackendAuth.getUserCredits();
        




        
        return { hasToken: !!hasToken, isLoggedIn, credits };
    },
    
    clearAuth: async function() {
        await BackendAuth.logout();

    }
};

// ========== GLOBAL QUICK SAVE LISTENER ==========
// Works anywhere on the page when text is highlighted
document.addEventListener('keydown', (e) => {
    if (e.altKey && e.key === 's') {
        const selectedText = window.getSelection().toString().trim();
        
        if (selectedText && selectedText.length > 0) {
            e.preventDefault();
            e.stopPropagation();
            
            console.log('ðŸ’¾ Global quick save triggered');
            
            savePrompt(selectedText).then(success => {
                if (success) {
                    showQuickSaveFeedback();
                }
            });
        }
    }
}, true); // Use capture phase

// ========== SAVE LAST RESPONSE LISTENER (Alt+R) ==========
// Works anywhere on the page - saves last Q&A exchange
document.addEventListener('keydown', async (e) => {
    if (e.altKey && e.key === 'r') {
        e.preventDefault();
        e.stopPropagation();
        
        console.log('ðŸ’¬ Save last response triggered (Alt+R)');
        
        const platform = detectAIPlatform();
        
        if (platform === 'unknown' || platform === 'gmail') {
            showNotification('âš ï¸ Not supported on this page', 'warning');
            return;
        }
        
        // Extract last Q&A exchange
        const lastExchange = extractLastExchange(platform);
        
        if (!lastExchange || !lastExchange.question || !lastExchange.answer) {
            showNotification('âš ï¸ No conversation found to save', 'warning');
            return;
        }
        
        // Build save object
        const saveData = {
            id: Date.now().toString(),
            type: 'qa_pair',
            
            // Content
            question: lastExchange.question,
            answer: lastExchange.answer,
            
            // Metadata
            title: generateTitleFromText(lastExchange.question),
            ai: platform,
            date: new Date().toISOString(),
            chatLink: window.location.href,
            
            // Detection
            hasCode: detectCode(lastExchange.answer),
            language: detectLanguage(lastExchange.answer)
        };
        
        // Save
        const success = await saveChatExchange(saveData);
        
        if (success) {
            showNotification(`âœ… Saved: ${saveData.title}`);
        } else {
            showNotification('âŒ Failed to save', 'error');
        }
    }
}, true);

// âœ… INITIALIZE THE EXTENSION

createUI();
initializeProfileHandlers();

// Check for platform changes and re-initialize both systems
// Initialize Magic Pill, Auto Smart Actions, File Analysis, and Gmail support
setTimeout(() => {
    const platform = detectAIPlatform();
    if (platform !== 'unknown') {

        initializeMagicPill();
        
        if (platform === 'gmail') {

        } else {
            
            initializeFileAnalysis();
        }
    }
}, 2000);

// Debug helper for testing in console
window.solthronDebugGallery = {
    testRename: function() {
        const items = shadowRoot.querySelectorAll('.gallery-item');
        console.log('ðŸ“Š Gallery items found:', items.length);
        
        if (items.length > 0) {
            console.log('âœ… First item ID:', items[0].dataset.id);
            console.log('âœ… Current category:', currentCategory);
            
            // Test if contextmenu listener is attached
            const textElement = items[0].querySelector('.gallery-item-text');
            console.log('âœ… Text element found:', !!textElement);
        } else {
            console.log('âŒ No gallery items found. Is the gallery open?');
        }
    },
    
    getCurrentCategory: function() {
        return currentCategory;
    },
    
    getShadowRoot: function() {
        return shadowRoot;
    }
};

console.log('ðŸ”§ Debug helper loaded. Try: window.solthronDebugGallery.testRename()');
